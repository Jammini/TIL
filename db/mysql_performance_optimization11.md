# 11장 MySQL 스케일링

# 스케일링이란?

스케일링(Scaling) : 증가하는 트래픽을 지원하는 시스템의 기능이다.

용량(Capacity) : 시스템의 용량은 주어진 시간 내에 수행할 수 있는 일의 양이다.

시스템의 확장성이 좋은 나쁜지에 대한 기준은 비용과 단순성으로 측정할 수 있다.

시스템의 실제 용량은 수용 가능한 성능을 제공하면서 달성할 수 있는 처리량으로 정의한다.

용량과 확장성은 성능과 무관하다.

- 시스템은 고속도로와 그 안의 모든 차선과 자동차이다.
- 성능은 자동차의 속도이고 용량은 차선 수에 최대 안전 속도를 곱한 값이다.
- 확장성은 교통 체증 없이 더 많은 차와 차선을 추가할 수 있는 정도를 말한다.

거시적인 관점에서 용량을 보면 아래와 같은 것들을 보면 유용하다.

데이터의 양 : 애플리케이션의 축적할 수 있는 엄청난 양의 데이터

사용자 수 : 사용자가 많으면 데이터가 누적되고 사용자가 많다는 것은 더 많은 트랜잭션을 의미한다.

사용자 활동 : 사용자가 좋아하는 새로운 기능으로 인해 사용자가 더 활성화되면 부하가 크게 증가 할 수 있다.

관련 데이터 세트의 크기 : 사용자 간에 관계가 있는 경우, 인기 많은 사용자로 인해 어려울 수 있다.

이처럼 스케일링 문제는 다양한 형태로 나타날 수 있다.

# 읽기 대 쓰기 바운드 워크로드

데이터베이스 아키텍처 확장을 고혀할 때 가장 먼저 검토해야 할 사항 중 하나는 읽기 바인딩된 워크로드 또는 쓰기 바인딩된 워크로드 중 어느 쪽을 확장하는가이다. 

### 워크로드의 이해

첫째, 사용자의 능력, 즉 앞에서 언급한 바와 같이 시간 경과에 따른 작업량이다. 데이터베이스의 경우 일반적으로 초당 쿼리 수로 요약한다.

쿼리나 CPU는 며책고, 읽기 쓰기 IOPS(HDD, SDD와 같은 하드 디스크의 파일 입출력 속도)와 디스크 처리량 제한, 네트워크 처리량 이런 것들이 워크로드와 직접 관련된 지연 시간에 영향을 미친다.

워크로드는 모든 유형의 쿼리와 지연 시간이 혼합된 것이다. CPU의 20%에서 1000개의 QPS를 처리하는 경우 동일한 지연 시간으로 4000개의 QPS를 추가할 수 있다.

### 읽기 바운드 워크로드

단일 소스 데이터베이스가 CPU 사용률이 높고 디스크 읽기 IOPS 또는 처리량이 많다면, 디스크를 매우 자주 읽거나 디스크에서 많은 행을 읽고 있다는 것을 나타낸다.

우선, 인덱스를 추가하고 쿼리를 최적화하고 캐시할 수 있는 데이터를 캐싱하여 이를 개선해라.

개선 사항이 소진되면 읽기 바인딩된 워크로드가 남게 되며 여기에서 레플리카를 사용하여 읽기 트래픽을 확장해라.

### 쓰기 바운드 워크로드

쓰기 바인딩된 로그가 발생할 수 있다.

- 회원 가입이 기하급수적으로 증가하고 있는 것
- 전자상거래의 성수기이며 추적할 주문 수와 함께 매출이 증가하고 있는 것
- 선거철이라 선거운동 홍보가 많이 뜨고 있는 것

이처럼 확장해야 하는 데이터베이스 쓰기가 기하급수적으로 늘어난다. 단일 소스 데이터베이스는 한동안 수직 확장이 가능하더라도 어느 수준까지만 확장된다.

병목이 쓰기 볼륨인 경우 개별 하위집합에서 병렬로 쓰기를 수용할 수 있게 데이터를 분할하는 방법을 생각해야 한다.

*만약, 읽기와 쓰기 두 가지 유형의 성장이 모두 보인다면?

스키마를 면밀히 검사하고 읽기에서 더 빠르게 성장하는 테이블이 있는지, 쓰기 요구량이 증가하는 다른 하위 집합이 있는지 확인하는 것이 중요하다.

데이터베이스 클러스터를 동시에 확장하려면 많은 사고와 문제가 발생한다. 읽기 및 쓰기를 독립적으로 확장하려면 서로 다른 기능 클러스터에서 테이블을 분리하는 것이 좋다. 이는 읽기 풀을 사용하여 읽기 트래픽을 훨씬 더 효과적으로 확장하기 위한 전제 조건이다.

# 기능적 샤딩

비지니스에서 기능을 기반으로 데이터를 분할하려면 데이터가 무엇인지 깊은 이해가 필요하다. 만약 각 테이블을 자체 기능적 데이터베이스에 넣는 다면 너무 많은 단편화로 인해 모든 것을 악화시킬 수 있다.

우려되는 대규모 단일/혼합 데이터베이스를 비즈니스 확장에 도움이 되는 합리적인 소규모 클러스터 세트로 분할할하려면 어떻게 해야 할까?

- 엔지니어링 팀의 구조에 따라 나누지 마라. 그 구조는 어느 순간 바뀐다.
- 비지니스 기능에 따라 테이블을 분할한다. 계정등록을 지원하는 테이블은 기존 고객 설정을 호스팅하는 테이블과 분리될 수 있으며 새로운 기능을 지원하는 테이블은 자체 데이터베이스에서 시작해야 한다.
- 데이터에 별도의 비즈니스 문제가 뒤섞이는 것을 너무 두려워하지 마라. 데이터 분리뿐만 아니라 애플리케이션 리팩터링이나 API 액세스 도입 문제가 있을 수 있다.

처음에는 명확하게 고유한 비즈니스 기능과 액세스 패턴이 있으므로 별도의 클러스터로 테이블을 쉽게 분리할 수 있지만, 시간이 지날수록 이러한 분리가 더 미묘해진다.

# 읽기 풀로 읽기 스케일링

클러스터의 레플리카는 두 가지 이상의 용도로 사용될 수 있다. 현재 소스가 어떤 이유로든 서비스에서 제거돼야 하는 경우 계획된 방식으로든 계획되지 않은 방식으로든 페일오버쓰기의 대상이 된다. 그러나 이러한 레플리카는 원본의 데이터와 일치하도록 지속적으로 업데이트를 실행하기 때문에 읽기 요청을 처리하는데 사용할 수도 있다.

<img width="233" alt="image" src="https://github.com/Jammini/TIL/assets/59176149/e4ef5d5d-cae9-4f9d-b3f7-8aad54c47f6d">

동일한 애플리케이션 노드가 가상 IP에 연결되어 해당 노드와 읽기 전용 레플리카 사이의 중간 계층 역할을 한다. 이것은 레플리카 읽기 풀이며 증가하는 읽기 로드를 둘 이상의 호스트로 분산할 수 있다. 이는 서로 다른 읽기 워크로드가 서로 영향을 미치지 않도록 하는 일반적인 방법이다.

보고 프로세스가 있거나 백업 프로세스가 모든 디스크 I/O 리소스를 소비하고 복제 지연을 일으키는 경향이 있는 경우, 이러한 작업을 수행하기 위해 하나 이상의 레플리카 노드를 생략하고 고객 대면 트래픽을 처리하는 읽기 풀에서 제외할 수 있다.

읽기 요청을 처리하는 데이터베이스 호스트가 두개 이상 있는 경우, 일반적으로 로드 밸런서를 사용하여 읽기 레플리카로 전송되는 모든 트래픽의 중개자 역할을 하는 가상 IP를 실행하는 것이다. 이를 위한 기술로는 HAProxy, 자체 호스팅하는 경우 하드웨어 로드 밸런서, 퍼블릭 클라우드 환경에서 실행 중인 경우 네트워크 로드 밸런서가 있다.

### 읽기 풀 구성 관리

이제 애플리케이션 노드와 레플리카 사이에 ‘게이트’가 있으므로 선택한 로드 밸런서를 사용하여 이 읽기 풀에 포함되거나 포함되지 않은 노드를 쉽게 관리할 수 있는 방법이 필요하다. 수동으로 관리되는 구성은 좋지 않다.

서비스 검색은 이 목록에 포함될 수 있는 호스트를 자동으로 검색하는데 사용할 수 있는 좋은 옵션이다. 즉, 서비스 검색 솔루션을 기술 스택의 일부로 배포하거나 클라우드 공급자의 관리형 서비스 검색 옵션에 의존할 수 있다.

### 읽기 풀에 대한 상태 확인(Health checks)

이때 읽기 레플리카가 정상이고 애플리케이션에서 읽기 트래픽을 허용할 준비가 되었다고 간주하는 허용 가능한 기준이 무엇인지 고려해야 한다.

상태확인은 어느 정도 수행할 것인지 결정하는 것은 래플리케이션 개발자 팀과의 대화를 통해서 모든 사람이 데이터베이스에서 읽을 때 에상하는 동작을 이해하고 조정할 수 있게 해야한다.

대부분의 경우 포트 검사만 사용하여 MySQL 프로세스가 활성 상태이며 연결을 허용할 수 있는지 확인할 수 있다. 그러나 복제 지연이 몇 초를 넘거나 복제가 실행되지 않은 경우에 대해서는 정교한 것이 필요할 수 있다.

### 로드 밸런싱 알고리즘 선택

다음 연결을 수신해야 하는 서버를 결정하기 위한 다양한 알고리즘이 있다.

무작위 : 로드 밸런서는 사용 가능한 서버 풀에서 무작위로 선택한 서버로 각 요청을 보낸다.

라운드 로빈 : 로드 밸런서는 A, B, C, A, B, C 등의 반복적인 순서로 서버에 요청을 보낸다.

가장 적은 연결 : 다음 연결은 활성화된 연결이 가장 적은 서버로 이동한다

가장 빠른 응답 : 요청을 가장 빨리 처리한 서버가 다음 연결을 수신한다.

해시 : 로드 밸런서는 연결의 소스 IP 주소를 해시하여 풀의 서버 중 하나에 매핑한다. 동일한 IP 주소에서 연결 요청이 올 때마다 로드 밸런서는 동일한 서버로 보낸다.

가중치 : 로드 밸런서는 다른 여러 알고리즘을 조합하여 가중치를 추가 할 수 있다.

MySQL에 가장 적합한 알고리즘은 워크로드에 따라 다르다. 워크로드에 가장 적합한 성능을 찾으려면 실험을 해야 한다.

# 대기열

설계상 가용성보다 일관성을 선호하는 데이터 저장소로 쓰기 트랜잭션을 확장할 경우 애플리케이션 계층 확장은 훨씬 더 복잡해진다. 하나의 소스 노드에 쓰는 애플리케이션 노드가 많을 수록 데이터베이스 시스템은 잠금 시간 초과, 교착 상태, 재시도해야 하는 쓰기 오류에 더 취약해진다. 이것들이 궁극적으로 고객이 직면하는 오류 또는 허용할 수 없는 지연으로 이어진다.

쓰기 로드에 대기열을 적용하는 경우 해야할 중요한 설계 선택중 하나는 대기열에 배치된 후 이러한 호출이 수행될 것으로 예상되는 원하는 시간 범위를 미리 결정하는 것이다. 요청이 대기열에 있는 시간의 증가를 모니터링하는 것은 이 전략이 제대로 실행되고 더 많은 병렬 쓰기로드를 지원하기 위해 데이터 세트를 분할을 해야 하는 경우에 대한 기준이 된다.

# 샤딩으로 쓰기 스케일링

최적화된 쿼리와 대기열에 있는 쓰기 트래픽 증가를 관리할 수 없는 경우 샤딩이 다음 옵션이다.

샤딩(Sharding) : 더 많은 소스 호스트에서 동시에 더 많은 쓰기를 실행할 수 있도록 데이터를 각기 다른 더 작은 데이터베이스 클러스터로 분할하는 것

샤딩 또는 파티셔닝에는 기능적 파티셔닝과 데이터 샤딩이라는 두가지 유형이 있다.

기능적 파티셔닝 : 다른 노드를 다른 작업에 할당하는 것

ex) 사용자 레코드를 한 클러스터에 배치하고 청구서를 다른 클러스터에 두는 예를 들 수 있다.

이 접근 방식을 사용하면 각 클러스터를 독립적으로 확장할 수 있다.

데이터 샤딩 : 데이터를 더 작은 조각 또는 샤드로 분할하고 다른 노드에 저장한다. 오늘날의 초대형 MySQL 애플리케이션을 확장하기 위한 가장 보편적이고 성공적인 접근 방식이다.

대부분의 애플리케이션은 샤딩이 필요한 데이터(일반적으로 매우 커질 데이터 세트의 일부)만 샤딩한다.

### 분할 방식 선택

샤딩의 가장 중요한 과제는 데이터를 찾고 검색하는 것이다. 데이터를 찾는 방법은 샤딩 방법에 따라 다르다.

쿼리는 항상 하나의 샤드에 국한되어야 한다. 데이터를 수평으로 샤딩할 때는 항상 샤드 간에 쿼리를 수행하지 않아도 된다. 

가장 중요하고 빈번한 쿼리가 가능한 적은 수의 샤드를 사용하는 것이 목표.

이 프로세스에서 가장 중요한 부분은 데이터에 대한 파티셔닝 키를 선택하는 것. 파티셔닝 키는 각 샤드에 어떤 행을 넣을지 결정함

좋은 파티셔닝 키는 일반적으로 데이터베이스에서 매우 중요한 엔티티의 기본 키. 이 키가 샤딩 단위를 결정. 예를 들어 사용자 ID 또는 클라이언트 ID로 데이터를 분할할 경우 샤딩 단위는 사용자 또는 클라이언트

엔티티-관계 다이어그램 등을 통해 데이터 모델을 도식화하여 파티셔닝 키 후보를 찾을 수 있음.

연결 정도에 따라 일부 데이터 모델은 다른 모델보다 샤딩하기 쉬움

### 다중 파티셔닝 키

데이터모델이 복잡한 경우 둘 이상의 파티셔닝 키를 가질 수도 있음.

예를 들어 블로그 애플리케이션의 데이터를 사용자 ID와 게시물 ID로 분할해야 할 수 있음. 사용자에 대한 모든 게시물에 게시물에 대한 모든 댓글을 보고싶어 하는 경우가 있음

사용자별 샤딩만 하면 게시물에 대한 댓글을 찾는데 도움이 되지 않고 게시물별로만 하면 사용자의 게시물을 찾는데 도움이 되지 않음. 두가지 유형의 쿼리가 모두 필요한 경우 두가지 방식으로 샤딩해야 함

### 샤드 간의 쿼리

대부분의 샤드 애플리케이션에는 여러 샤드로부터 데이터를 수집하거나 결합해야 하는 쿼리가 최소한 몇개 존재한다.

ex) 가장 인기 있는 사용자를 보여주는 경우, 모든 샤드에 액세스 해야 한다.

단일 쿼리로 간주하는 것을 분할하고 샤드당 하나씩 여러 개의 쿼리를 병렬로 분할하고 실행해야 하므로 쿼리가 제대로 작동하도록 하는 것이 데이터 샤딩을 구현하는데 있어 가장 어려운 부분이다.

이러한 쿼리는 샤드 내 쿼리보다 훨씬 느리고 비용이 많이 들기 때문에 일반적으로 보다 적극적인 캐싱도 필요하다.

# 요약

샤딩과 파티셔닝 모두를 지원하는 가장 인기 있는 오픈 소스 두가지. Vitess, ProxySQL

확장설 병목 현상을 살펴보기 전에 쿼리를 최적화하고 인덱스를 확인하고 MySQL 에 대한 견고한 구성이 있는지 확인해라.

최적화되면 읽기 또는 쓰기 바운드 여부를 결정한 다음 당면한 문제를 해결하는데 가장 적합한 전략을 골라라.

읽기 바인딩된 워크로드의 경우 복제 지연이 극복할 수 없는 문제가 아닌 한 읽기 풀로 이동하는 것이 좋다. 지연의 문제가 있거나 쓰기 제한 문제가 있는 경우 다음 단계로 샤딩을 고려해야한다.