# 5장 서버 설정 최적화

MySQL 서버에 적합한 설정 파일을 만드는 방법을 설명한다.

첫째, MySQL의 내부 구조와 동작을 이해하는 것이 가장 좋다.

둘째, MySQL을 어떻게 설정하는지에 대한 가이드로 시작해라. 

셋재, 원하는 설정을 현재 설정과 비교한 후 중요하고 가치 있다고 판단되는 차이점을 수정해라.

일반적으로 MySQL 기본 설정이 좋으며 스키마 최적화, 인덱스, 쿼리디자인에 신경쓰는 것이 좋다.

그래도 건드려 보아야 한다면?

기본값이 최적의 값이 아닌게 확실하지 않다면 바꾸지 마라

# MySQL의 설정이 동작하는 방법

Unix 계열 시스템에서 구성 파일은 일반적으로 `/etc/my.cnf` 또는 `/etc/mysql/my.cnf` 에 존재한다.

서버가 어떤 파일을 읽는지 모르는 경우 아래와 같은 명령어를 통해 확인하면 된다.

```
$ which mysqld
/usr/sbin/mysqld
$ /usr/sbin/mysqld --verbose --help | grep -A 1 'Default options'
Default options are read from the following files in the given order: 
/etc/mysql/my.cnf ~/.my.cnf /usr/etc/my.cnf
```

### 구문, 범위 및 다이내믹 여부(Dynamism)

설정은 밑줄 또는 대시로 구분된 단어와 함께 소문자로 작성된다.

- max_connections 변수는 전역 변수이다.
- sort_buffer_size 변수에는 전역으로 기본값이 있지만 세션별로도 설정할 수 있다.
- join_buffer_size 변수는 전역으로 기본값을 가지며 세션별로도 설정할 수 있지만, 여러 테이블을 조인하는 하나의 쿼리도 조인당 하나의 조인 버퍼를 할당 받기에 쿼리당 여러개의 조인 버퍼를 사용할 수 있다.

**변수를 동적으로 설정하면, MySQL이 종료되면 해당 설정이 사라진다. 유지하려면 설정파일도 함께 업데이트 해야한다.**

### 지속(Persisted) 시스템 변수

MySQL 8.0에는 지속 시스템 변수라는 새로운 기능이 도입되어 SET PERSIST를 사용하면 런타임에 한 번 값을 설정할 수 있다.

### 하지 말아야 할 것

벤치마크를 셋업하고 최적의 설정을 찾기 위해 설정을 반복적으로 변경해서 서버를 튜닝하지마라. 잠재적인 이득이 작아 시간낭비가 된다.

백업 확인, 쿼리 계획 변경 모니터링 등과 같은 다른 작업에 그 시간을 투자해라.

# 메모리 사용량 설정

### InnoDB 버퍼 풀

InnoDB 버퍼 풀은 일반적으로 성능에 가장 중요한 변수이기 때문에 다른 어떤 것보다 더 많은 메모리가 필요하다.

InnoDB 버퍼 풀은 인덱스를 캐시할 뿐만 아니라 행 데이터, 어댑티브 해시 인덱스, 변경 버퍼, 잠금 및 기타 내부 구조도 저장한다. 또한 쓰기 지연을 돕기 위해 버퍼 풀을 사용하므로 많은 쓰기를 병합하고 그것들을 순차적으로 수행할 수 있다.

즉, InnoDB는 버퍼 풀에 크게 의존하므로 충분한 메모리를 할당해야 한다.

### 스레드 캐시

스레드 캐시는 현재 연결된 스레드와, 연결되어 있지 않지만 새 연결을 제공할 준비가 된 스레드를 보유한다.

**캐시에 스레드가 있고 새 연결이 생성될 때 MySQL은 캐시에서 스레드를 제거하고 새 연결에 제공한다.(?)**

연결이 닫히면 MySQL은 여유 공간이 있는 경우 스레드를 캐시에 다시 보관한다. 공간이 없으면 MySQL은 스레드를 제거한다.

MySQL이 캐시에 여유 스레드가 있다면, 각 연결에 대해 새 스레드를 생성할 필요가 없기 때문에 연결 요청에 빠르게 응답 할 수 있다.

# MySQL의 I/O 동작 설정

성능을 높이고 ACID 속성을 보장하도록 설계된 버퍼와 파일의 복잡한 체인이 있으며 체인의 각 부분을 설정할 수 있다.

일반적인 사용을 위해 변경해야 할 사항은 InnoDB 로그 파일 크기, InnoDB가 로그 버퍼를 플러시하는 방법, InnoDB가 I/O를 수행하는 방법이다.

### InnoDB 트랜잭션 로그

InnoDB는 트랜잭션 커밋 비용을 줄이기 위해 로그를 사용한다. 각 트랜잭션이 커밋될 때 버퍼 풀을 디스크로 플러시하는 대신 트랜잭션을 로그로 남긴다.

InnoDB는 백그라운드 스레드를 사용해서 변경사항을 데이터 파일에 지능적으로 플러시한다. 사실상 트랜잭션 로그는 랜덤 데이터 파일 I/O를 대부분 순차적인 로그 파일 및 데이터 파일I/O로 변환한다(?)

### 로그 버퍼

InnoDB가 데이터를 변경할 때 변경 기록을 로그 버퍼에 기록해서 메모리에 보관한다.

버퍼가 가득 찼을 때나 트랜잭션이 커밋될 때, 또는 초당 한 번 중 먼저 도래하는 시점에 버퍼를 디스크의 로그 파일로 플러시한다.

버퍼 크기는 대용량 BLOB레코드를 쓰지 않는 다면 일반적으로 권장 범위는 1-8MB이다.

### InnoDB가 로그 버퍼를 플러시하는 방법

InnoDB가 로그 버퍼를 디스크의 로그 파일로 플러시 할 때 뮤텍스로 버퍼를 잠그고 원하는 지점까지 플러시한 다음 나머지 항목을 버퍼의 앞으로 이동한다. 뮤텍스가 해제될 때 하나 이상의 트랜잭션이 로그 항목을 플러시 할 준비가 되는 것도 가능하다.

로그 버퍼를 로그 파일에 쓰는 것과 로그를 영구 저장소에 플러시하는 것의 차이를 아는것이 중요하다.

0 : 로그 버퍼를 로그 파일에 쓰고 1초마다 로그 파일을 플러시

1 : 로그 버퍼를 로그 파일에 쓰고 트랜잭션이 커밋될때 마다 영구 저장소에 플러시(기본설정)

2 : 커밋할 때 마다 로그 버퍼를 로그 파일에 쓰지만 플러시 하지 않고 1초마다 플러시 예약

0, 2는 일반적으로 비정상 종료나 정전이 발생한 경우 1초의 데이터 손실을 초래한다.

1이 아니면 트랜잭션이 손실 될 수 있다. 지속성(ACID의 D)에 관심이 없다면 다른 설정이 유용할 수 도 있다.

### InnoDB 테이블스페이스

본질적으로 디스크에 있는 한개 또는 많은 파일을 포괄하는 가상 파일시스템인 테이블스페이스에 데이터를 보관한다. 

테이블과 인덱스를 저장하는 것 뿐만 아니라 언두 로그(이전 행 버전을 다시 생성하는데 필요한 정보), 변경 버퍼, 더블라이트 버퍼 및 기타 내부 구조를 테이블 스페이스에 유지한다.

# MySQL 동시성 설정

MySQL 5.7 이상을 운영하고 있지 않는 경우라면 해결책은 일반적으로 서버를 업그레이드하는 것이다.

최신 버전의 MySQL 중 하나로 업그레이드하면 대부분의 경우 동시성을 제한할 필요가 없다.

병목현상이 발생하면 가장 좋은 방법은 데이터를 샤딩(sharding)하는 것이다.

# 안전 설정

서버를 보다 안정적으로 만드는 여러 설정을 활성화 할 수 있다. 그러나 비용을 지불하기에 일부 합리적인 옵션들만 살펴보자.

- max_connect_error : ****지정된 이상의 연결장애가 발생하면 접속 호스트를 블락시킴.
- max_connections : 동시 접속자 수.
- skip_name_resolve : IP 주소를 호스트네임으로 바꾸는 과정을 수행하여 접속시에 불필요한 부하가 발생. skip-name-resolve를 설정하고 접속시에 IP 기반으로 접속을 하게 되면 hostname lookup 과정을 생략
- sql_mode : 서버 동작을 변경하는 다양한 옵션 허용.
- sysdata_is_now : SYSDATE() 함수를 원하지 않은 경우 이 옵션을 활성화해 활용할 수 있음.
- read_only and super_read_only : read_only옵션은 권한이 없는 사용자가 레플리카를 변경하는 것을 방지 한다. 즉 복제를 통해서만 변경을 수신해야함. 레플리카를 읽기 전용 모드로 설정 권장.

# 고급 InnoDB설정

- innodb_autoinc_lock_mode
- innodb_buffer_pool_instances
- innodb_io_capacity
- innodb_read_io_threads와 innodb_write_to_threads
- innodb_strict_mode
- innodb_old_blocks_time