# 7장 고성능을 위한 인덱싱

인데스(MySQL에서는 키)는 스토리지 엔진이 행을 빠르게 찾기 위해 사용하는 데이터 구조이다.

인덱스 최적화는 쿼리 성능을 향상시키는 가장 강력한 방법이다. 인덱스는 성능을 수십 배나 향상 시킬 수 있다.

# 인덱싱 기본

MySQL에서 인덱스가 어떻게 작동하는지 가장 쉬운 방법은 책의 목차를 생각해보자.

특정 주제가 책에서 논의 되는 위치를 찾으려면 목차를 보면 된다.

### 인덱스 유형

인덱스는 서버 계층이 아닌 스토리지 엔진 계층에 구현된다. 따라서 인덱싱은 각 엔진에서 조금씩 다르게 동작하며 모든 엔진이 모든 유형의 인덱스를 지원하는건 아니다.

### B-트리 인덱스

일반적으로 B-트리 데이터 구조를 사용하여 데이터를 저장하는 B-트리 인덱스를 참조한다. 대부분의 MySQL스토리지 엔진은 이 인덱스 유형을 지원함.

B-트리 인덱스는 스토리지 엔진이 원하는 데이터를 찾기 위해 전체 테이블을 스캔할 필요가 없기 때문에 데이터 액세스 속도를 향상시킨다. 

### 적응형 해시 인덱스

InnoDB 스토리지 엔진에는 적응형 해시 인덱스하는 특별한 기능이 있다.

InnoDB는 일부 인덱스 값이 매우 자주 액세스 되고 있음을 감지하면 B-트리 인덱스 위에서 메모리에 해시인덱스를 구축한다.

### B-트리 인덱스를 사용할 수 있는 쿼리 유형

B-트리 인덱스는 전체 키 값, 키 범위 또는 키 접두사로 조회하는데 적합하며, 조회가 인덱스의 가장 왼쪽 접두사를 사용하는 경우에만 유용하다.

### 인덱스의 이점

인덱스를 통해 서버는 테이블에서 원하는 위치로 빠르게 이동할 수도 있다 또한, 인덱스를 생성하는 데 사용된 데이터 구조의 속성을 기반으로도 추가 이점이 있다.

B-트리 인덱스는 데이터를 정렬된 순서로 저장하여 작동하며, MySQL은 ORDER BY 및 GROUP BY와 같은 절이 있는 쿼리에 이를 이용할 수 있다.

인덱스는 실제로 값의 복사본을 저장하므로 인덱스만으로 일부 쿼리를 수행할 수 있다.

- 인덱스는 서버가 검새해야 하는 데이터의 양을 줄인다
- 인덱스는 서버가 정렬 및 임시 테이블을 생성하지 않게 도와준다.
- 인덱스는 랜딤 I/O를 순차 I/O로 바꾼다.

# 고성능을 위한 인덱싱 전략

올바른 인덱스를 만들고 제대로 사용하는 것은 쿼리 성능을 높이는데 필수적이다.

### 프리픽스(Prefix) 인덱스 및 인덱스 선택성

전체 값 대신 처음 몇개의 문자를 인덱싱하면 공간을 절약하고 성능을 향상시킬 수 있다. 이렇게 함으로써 인덱스가 더 적은 공간을 사용하지만 선택도 줄어든다. 인덱스 선택성은 테이블의 총 행 수에 대한 고유 인덱스 값 수의 비율이며, 범위는 1/총 행 수 에서 1까지 이다.

**BLOB**, **TEXT** 컬럼이나 아주 긴 **VARCHAR** 컬럼을 인덱싱한다면 프리픽스 인덱스를 정의해야 한다

중요한 건 선택도를 충분히 확보할 정도로 길지만 공간을 절약할 만큼은 짧은 프리픽스를 선택하는 일이다. 

알맞은 프리픽스 길이를 계산하는 다른 방법은 전체 컬럼의 선택도를 계산한 후 프리픽스의 선택도가 그 값에 가까워지게 만드는 것이다. 전체 컬럼의 선택도를 알아내는 방법은 이렇다.

```sql
SELECT COUNT(DICTINCT city) / COUNT(x) FROM sakila.city_demo;
```

예시 결과가 0.0312 라고 가정해보자

목표 선택도를 0.031 정도로 잡으면 프리픽스는 평균적으로 만족스러울 것이다. 쿼리 하나로 다양한 길이를 평가하는 것도 가능한데 이는 테이블이 아주 클 때 유용하다.

```sql
SELECT 
   COUNT(DICTINCT LEFT(city, 3) / COUNT(x) AS sel3,
   COUNT(DICTINCT LEFT(city, 4) / COUNT(x) AS sel4,
   COUNT(DICTINCT LEFT(city, 5) / COUNT(x) AS sel5,
   COUNT(DICTINCT LEFT(city, 6) / COUNT(x) AS sel6,
   COUNT(DICTINCT LEFT(city, 7) / COUNT(x) AS sel7
FROM sakila.city_demo;

sel3: 0.0238
sel4: 0.0293
sel5: 0.0305
sel6: 0.0309
sel7: 0.0310
```

이 쿼리는 일곱 글자에 가까워지면서 프리픽스의 길이 증가가 조금씩 선택도를 개선시킴을 보여준다.

평균 선택도만 바라보는 건 좋은 생각이 아니다. 최악의 선택도에 대해서도 생각해야 한다. 데이터가 고르지 못하다면 그런 생각이 함정이 될 수 있다.

이제 예제 데이터에서 알맞은 값을 찾았으니 컬럼에 대한 프리픽스 인덱스를 생성하는 법을 알아보자

```sql
ALTER TABLE sakila.city_demo ADD KEY (city(7));
```

프리픽스 인덱스의 단점이라면 MySQL 은 프리픽스 인덱스를 ORDER BY 또는 GROUP BY 쿼리에 활용하지도 커버링 인덱스로 활용하지도 못한다.

### 다중 열 인덱스

열을 여러개 또는 모든 열을 개별적으로 인덱싱 하지마라.

많은 열에 대한 개별 인덱스는 MySQL이 대부분의 쿼리 성능을 향상시키는 데 도움이 되지 않는다. 인덱스 병합으로 알려진 전략을 사용하여 제대로 인덱싱 되지 않은 테이블에 약간 대처가 가능하다.

EXPLAIN에서 인덱스 병합이 확인될 경우, 쿼리와 테이블 구조를 검토하여 이 방법이 가장 최선인지 확이해야 한다.

### 좋은 열 순서 선택하기

```sql
SELECT * FROM payment WHERE staff_id = 2 AND customer_id = 584;
```

테이블의 값 분포를 살펴보고 선택성이 더 옾은 열을 확인해봐야한다.

WHERE 절에서 각 술어의 카디널리티를 계산하도록 하자

```sql
SELECT SUM(staff_id = 2), SUM(customer_id = 584) FROM payment
************************ 1. row ************************
SUM(staff_id = 2): 7992
SUM(cusomer_id = 584): 30
```

테이블에서 더 적은 수의 행과 일치 하기 때문에 인덱스에 먼저 cutomer_id를 우선 배치해야 한다.

그런 다음 쿼리를 다시 실행하여 특정 고객 ID로 선택한 행 범위 내에 선택적인 staff_id가 얼마나 있는지 확인할 수 있다.

선택한 쿼리에 대해 제공된 특정 상수에 따라 결과가 달라지므로 이 기법에 주의해야한다.

### 클러스터형 인덱스

데이터베이스 테이블의 물리적인 저장 순서를 인덱스의 키 값 순서와 일치시키는 인덱싱 방식이다.

테이블당 하나의 클러스터형 인덱스만 가질 수 있으며, 클러스터형 인덱스를 설정하면 해당 인덱스의 키 값을 기준으로 데이터가 저장된다.

즉, 클러스터형 인덱스는 테이블의 데이터 자체를 정렬된 상태로 유지한다.

- **데이터 정렬**: 클러스터형 인덱스는 데이터를 인덱스 키 값의 순서대로 물리적으로 저장한다. 따라서 인덱스를 스캔하는 것이 데이터를 스캔하는 것과 같다.
- **테이블 당 한 개**: 한 테이블에는 하나의 클러스터형 인덱스만 존재할 수 있다. 이는 데이터가 하나의 순서로만 정렬될 수 있음을 의미한다.
- **검색 속도 향상**: 범위 검색이나 정렬된 데이터의 순차적 접근에 효율적이다. 인덱스 키에 기반한 검색이 빠르며, 인접한 데이터를 함께 읽기 때문에 디스크 I/O를 최소화할 수 있다.
- **데이터 삽입, 삭제, 수정의 비용**: 데이터를 삽입하거나 삭제할 때, 데이터의 물리적인 순서를 유지하기 위해 추가적인 작업이 필요할 수 있다. 이로 인해 클러스터형 인덱스가 없는 테이블에 비해 상대적으로 비용이 더 들 수 있다. 그래서 순차적으로 인덱스 값을 삽입하는 것이 좋다.

### 커버링 인덱스

쿼리를 충족시키기 위해 데이터베이스 테이블의 데이터를 조회할 필요 없이 인덱스 자체에서 모든 필요한 데이터를 제공할 수 있는 인덱스를 말한다.

즉, 쿼리에 사용된 모든 컬럼이 인덱스의 일부로 구성되어 있어서, 인덱스만으로 쿼리의 결과를 반환할 수 있을 때 해당 인덱스를 '커버링 인덱스'라고 한다.

장점

- **성능 향상**: 데이터 파일에 대한 접근 없이 인덱스에서 바로 데이터를 얻을 수 있기 때문에, 디스크 I/O가 줄어들고 쿼리 성능이 크게 향상된다.
- **리소스 절약**: 쿼리 처리 시 필요한 리소스가 감소하여 시스템의 전반적인 부하를 줄일 수 있다.

### 중복과 이중 인덱스

중복 인덱스 : 같은 데이터 컬럼에 대해 여러 인데긋가 생성된 상태

인덱스가 중복되면 데이터 삽입, 삭제, 수정시 불필요한 오버헤드가 발생하고 추가적인 디스크 공간을 차지한다

이중 인덱스 : 두개 이상의 컬럼을 결합하여 생성된 인덱스

이중인덱스를 생성할 때는 컬럼의 순서가 중요하다. 쿼리의 조건과 일치하는 컬럼 순서대로 인덱스를 구성해야 최적의 성능을 발휘할 수 있다.

중복인덱스는 피하고, 이중 인덱스는 쿼리 성능을 최적화할 수 있는 방법으로 적절히 활용해야 한다.

### 사용하지 않는 인덱스

중복인덱스와 이중인덱스 외에도 서버에서 사용하지 않는 인덱스가 있을 수 있다. 부담만 가중되므로 제거하는 것을 고려해야 한다.

# 인덱스와 테이블 유지 관리

테이블과 인덱스가 제대로 작동하도록 유지 관리해야한다. 손상 발결 및 수정, 정확한 인덱스 통계 유지 및 조각화 감소이다.

### 테이블 손상 찾기 및 복구

데이터 손상이 발생한 경우 가장 중요한 것은 손상이 발생한 원인을 파악하는 것이다. 단순히 데이터를 복구하지 마라.

### 인덱스 통계 업데이트

스토리지 엔진이 쿼리가 검사할 행수에 대한 부정확한 정보를 옵티마이저에 제공하거나 쿼리 계획이 너무 복잡하여 여러 단계에서 일치하는 행 수를 정확히 알 수 없는 경우 옵티마이저는 인덱스 통계를 사용하여 행 수를 추정한다.

### 인덱스 및 데이터 단편화 줄이기

B-트리 인덱스가 조각화되어 성능이 저하 될 수 있다. 조각난 인덱스는 디스크에서 제대로 채워지지 않거나 순차적이지 않을 수 있다.

- 행 단편화 : 행이 여러 위치에 여러 조각으로 저장될 때 발생
- 행 내부 단편화 : 논리적으로 순차적인 페이지 또는 행이 디스크에 순차적으로 저장되지 않을때 발생
- 여유 공간 단편화 : 데이터 페이지에 빈 공간이 많을 때 발생

### 요약

응답시간이 오래 걸리거나 서버에 너무 많은 부하를 주는 쿼리를 찾아 스키마, SQL 및 인덱스 구조를 검토해라.