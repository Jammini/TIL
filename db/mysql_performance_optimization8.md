# 8장 쿼리 성능 최적화

일반적인 쿼리 설계 고려 사항, 즉 쿼리가 제대로 수행되지 않을 때 먼저 고려해야 할 사항부터 설명한다. 그 다음 쿼리 최적화 및 서버 내부에 대해 자세히 알아본다.

MySQL이 특정 쿼리를 실행하는 방법을 알아보고 쿼리 실행 계획을 변경하는 방법에 대해 배운다.

# 쿼리가 느린 이유는 무엇일까요?

빠른 쿼리를 작성하기 전에  응답 시간이 중요하다는 것을 기억해라.

모든 경우에 작업이 불필요하게 수행되거나 너무 많이 수행되거나 너무 느림으로 인해 과도한 시간이 소모 될 수 있다. 최적화의 목표는 작업을 제거하거나 줄이거나 더 빠르게 함으로써 이러한 문제를 방지하는 것이다.

# 느린 쿼리 기본: 데이터 액세스 최적화

성능이 떨어지는 쿼리를 두 단계로 분석하는 것이 유용하다.

1. 애플리케이션이 필요 이상으로 많은 데이터를 검색하는지 확인한다. 일반적으로 너무 많은 행에 액세스하고 있음을 의미하지만 너무 많은 열에 액세스할 수도 있다.
2. MySQL 서버가 필요 이상으로 많은 행을 분석하고 있는지 확인한다.

### 데이터베이스의 불필요한 데이터를 요청하고 있습니까?

일부 쿼리는 필요한 것보다 더 많은 데이터를 요청한 다음 일부를 버린다. 이것은 서버의 추가 작업을 요구하고, 네트워크 오버헤드가 추가 되며, 애플리케티션 서버의 메모리와 CPU 리소스를 소비한다.

1. 필요 이상의 행을 가져오기
    - 모든 행을 가져오고 대부분을 버리는데 최상의 해결책은 LIMIT 절을 추가하는 것이다.
2. 다중 테이블 조인에서 모든 열 가져오기
    - 조인된 모든 열을 가져오지 말고 필요한 테이블의 열만 SELECT해라
3. 모든 열 가져오기
    - SELECT * 은 보편적으로 권장하지 않는다. 모든 열을 검색하면 서버에 대한 I/O, 메모리 및 CPU 오버헤드가 가중된다.
4. 동일한 데이터를 반복적으로 가져오기
    - 처음 가져올 때 캐시하고 나중에 다시 사용할 수 있도록 접근 방식을 효율적으로 관리해라.

### MySQL이 너무 많은 데이터를 검사하고 있습니까?

MySQL에서 가장 간단한 쿼리 비용 메트릭을 보자

- 응답 시간
- 검사된 행 수
- 반환된 행 수

쿼리를 실행하고 대략적으로 얼마나 빠르게 실행하는지 변환하기 위해 MySQL이 내부적으로 액세스해야 하는 데이터의 양을 대략 반영한다.

### 응답시간

응답 시간은 서비스 시간과 대기열 시간의 합이다.

서비스 시간 : 서버가 실제로 쿼리를 처리하는데 걸리는 시간

대기열 시간 : 서버가 실제로 쿼리를 실행하지 않는 응답시간의 일부

즉, I/O 작업이 완료되기를 기다리거나 행 장금을 기다리는 등의 작업이다.

쿼리 실행 계획 및 관련 인덱스를 검토하고, 필요한 차례 및 랜덤 I/O 작업 수를 파악한 후, 하드웨어가 이를 수행하는데 걸리는 시간을 곱하는 것이다. 이를 모두 합산한 값을 척도로 하여 쿼리가 예상 속도보다 느린디 혹은 느려질 수 밖에 없는지 판단해라.

### 검사한 행과 반환된 행

검사되는 행 수를 고려하면 쿼리가 얼마나 효울적으로 필요한 데이터를 찾는지 유용하다.

검사된 행의 수는 반환된 수와 동일한 것이 이상적이지만 실제로 거의 불가능하기에 잘못된 쿼리를 찾는데 완벽한 메트릭은 아니다.

### 검사한 행 및 액세스 유형

쿼리 비용을 고려할 때 테이블에서 단일 행을 찾는 비용을 고려해라.

- 일치하지 않는 행을 제거하기 위해 인덱스 조회 작업에 조건을 적용한다. 이것은 스토리지 엔진 계층에서 발생한다.
- 행 액세스를 방지하고 인덱스에서 각 결과를 검색한 후 일치하지 않는 행을 필터링하려면 커버링 인덱스를 사용한다. 이것은 서버 계층에서 발생하지만 테이블에서 행을 읽을 필요는 없다.
- 테이블에서 행을 검색한 다음 일치하지 않는 행을 필터링 한다(Extra 열의 Using where) 이것은 서버 계층에서 발생하며 서버가 행을 필터링하기 전에 테이블에서 행을 읽어야 한다.

좋은 인덱스를 사용하면 쿼리가 적절한 액세스 유형을 얻고 필요한 행만 검사할 수 있다.

# 쿼리를 재구성하는 방법

### 복잡한 쿼리 대 많은 쿼리

복잡한 쿼리를 여러 개의 단순한 쿼리로 분할하는것이 더 나은지 여부

비용을 따져보고 작업량을 줄이는 전략을 선택해라.

### 쿼리 자르기

쿼리를 분할하는 또 다른 방법은 쿼리는 기본적으로 동일하게 유지하되 매번 더 적은 수의 행에 영향을 주는 보다 작은 청크로 실행하는 것이다.

### 조인 분해

다중 테이블 조인 대신 여러 단일 테이블 쿼리를 실행한 다음 애플리케이션에서 조인을 수행하여 조인을 분해 할 수 있다.

- 캐싱이 더 효율적일 수 있다. 많은 애플리케이션은 테이블에 직접 매핑되는 객체를 캐싱한다. 이 예에서 mysql 태그를 가진 객체가 이미 캐시된 경우 애플리케이션은 쿼리를 건너 뛸 수 있다.
- 개별적으로 쿼리를 실행하면 잠금 경합을 줄일 수 있다.
- 애플리케이션에서 조인을 수행하면 테이블을 다른 서버에 배치할 수 있어 DB를 쉽게 확장가능하다.
- 불필요한 행 액세스를 줄일 수 있다.

따라서, 이전 쿼리의 많은 데이터를 캐시 및 재사용하거나, 여러 서버에 데이터를 분산 배포하거나 큰 테이블의 IN() 목록으로 조인을 대체하거나, 여러 번 같은 테이블을 참조할 때 애플리케이션에서 조인을 수행하는 것이 더 효율적일 수 있다.

# 쿼리 실행 기본 사항

MySQL 서버에서 고성능이 필요하다면 시간을 투자하여 MySQL이 쿼리를 최적화하고 실행하는 방법을 배워라.

1. 클라이언트는 SQL 문을 서버로 보낸다.
2. 서버는 이를 구문 분석, 전처리 및 쿼리 실행 계획으로 최적화한다.
3. 쿼리 실행 엔진은 스토리지 엔진 API를 호출하여 계획을 실행한다.
4. 서버는 결과를 클라이언트로 보낸다.

<img width="573" alt="image" src="https://github.com/Jammini/TIL/assets/59176149/3b431a52-5ebb-4459-bd3b-41b09091e436">

## MySQL 클라이언트/서버 프로토콜

프로토콜은 반이중으로 MySQL 서버가 메시지를 보내거나 받을 수 있지만 둘 다 할 수는 없다.

## 쿼리 상태

MySQL 연결 또는 스레드에는 주어진 시간에 수행 중인 작업을 보여주는 상태가 있다.

- Sleep : 스레드가 클라이언트의 새 쿼리를 기다리는 중
- Query : 스레드가 쿼리를 실행 중이거나 결과를 클라이언트로 다시 보낸다.
- Locked : 스레드는 서버 수준에서 테이블 잠금이 부여되기를 기다리고 있다.
- Analyzing and statistics : 스레드가 스토리지 엔진 통계를 확인하고 쿼리를 최적화
- Copying to tmp table [on disk] : 스레드가 쿼리를 처리하고 결과를 임시 테이블에 복사하고 있다.
- Sorting result : 스레드가 결과 셋을 정렬하고 있다.

## 쿼리 최적화 프로세스

파서와 전처리기

파서 : 쿼리를 토큰으로 나누고 토큰에서 파스트리를 만든다. 파서는 MySQL의 SQL 문법을 사용하여 쿼리를 해석하고 검증한다. ex) 문법 검증

전처리기 : 파스트리에서 파서가 확인할 수 없는 추가의미 체계를 학인한다. ex) 테이블, 열 참조가 모호한지 검증, 권한 확인

### 쿼리 옵티마이저

파스트리가 유효하고 옵티마이저가 쿼리 실행 계획으로 전환할 준비

옵티마이저가 최상의 옵션을 찾는다. 즉, 다양한 실행 계획의 비용을 예측하고 가장 저렴한 것을 선택한다.

옵티마이저는 추정치에 캐싱효과도 포함하지 않고 모든 읽기로 디스크 I/O가 발생한다고 가정한다.

옵티마이저는 다양한 이유로 항상 최상의 계획을 선택하지 않는다.

### MySQL의 조인 실행 전략

모든 조인을 중첩 루프 조인으로 처리했다. MySQL이 루프를 실행하여 테이블에서 행을 찾은 후, 다음 테이블에서 일치하는 행을 찾기 위해 중첩 루프를 실행한다는 것을 의미한다. 조인은 각 테이블에서 일치하는 행을 찾을 때까지 계속된다. 그런 다음 SELECT 목록에 지정된 열에서 행을 작성하고 반환한다.

8.0.20 버전부터 블록 중첩 루프 조인이 더 이상 사용되지 않는 대신 해시 조인이 이를 대체 했다.

### 실행 계획

MySQL은 다른 많은 데이터베이스 제품처럼 쿼리를 실행하기 위해 바이트코드를 생성하지 않는다. 쿼리 결과를 생성하기 위헤 따르는 명령의 트리이다.

왼쪽으로 치우친 트리의 형태를 취한다.

### 조인 옵티마이저

MySQL 쿼리 옵티마이저의 가장 중요한 부분은 다중 테이블 쿼리에 대한 최상의 실행 순서를 결정하는 조인 옵티마이저이다. 

조인 옵티마이저가 조인순서를 바꾸는 등 쿼리를 재정렬하여 실행 비용을 줄이는데 효과적이다.

## 쿼리 실행 엔진

구문 분석 및 최적화 단계는 MySQL의 쿼리 실행 엔진이 쿼리를 처리하는데 사용하는 쿼리 실행 플랜을 출력한다.

플랜은 다른 데이터베이스가 쿼리를 실행하는 횟수를 나타내기 위해 실해하는 바이트코드가 아니라 데이터 구조이다.

## 클라이언트에게 결과 반환하기

쿼리를 실해하는 마지막 단계는 클라이언트에 회신하는 것이다. 쿼리에서 결과 셋을 반환하지 않는 경우도 영향을 받은 행 수와 같은 정보로 클라이언트에게 응답한다.

# MySQL 쿼리 옵티마이저의 한계

MySQL의 쿼리 실행 방식은 모든 종류의 쿼리를 최적화하는 데 이상적이지 않다.

### UNION 제한 사항

MySQL은 때때로 결과를 제한하거나 추가적인 최적화를 위해 UINION 외부에서 내부로 조건을 강제할 수 없다.

ex) UNION 내부의 개별 쿼리가 LIMIT의 이점을 얻을 수 있다고 생각되거나 다른 쿼리와 결합하여 ORDER BY 절의 적용을 받게 될 것으로 생각된다면 해당 절을 UNION 각 부분 안에 넣어야 한다.

### 동등 전파

때때로 동등 전파는 예상치 못한 비용을 초래할 수 있다.

ex) 열을 서로 동일하게 설정하는 WHERE, ON, USING절로 인해 옵티마이저는 인식하는 열의 거대한 IN() 목록이 다른 테이블의 일부 열과 같을때

### 병렬 실행

MySQL은 여러 CPU에서 단일 쿼리를 병렬로 실행할 수 없다. 이 기능은 다른 데이터베이스 서버에서 제공하지만 MySQL은 제공하지 않는다.

### 동일한 테이블에 대한 SELECT와 UPDATE

MySQL은 테이블레엇 UPDATE를 동시에 실행하는 동안 테이블에서의 SELECT를 허용하지 않는다.

# 특정 유형의 쿼리 최적화

대부분 버전에 따르 다르며 MySQL 버전에는 적용되지 않을 수 있다. 언젠가 서버가 이러한 최적화 작업의 일부 또는 전부를 자체적으로 수행할 수도 있다.

### COUNT() 쿼리 최적화

### 조인 쿼리 최적화

### ROLLUP으로 GROUP BY 최적화

### LIMIT 및 OFFSET 최적화

### SQL_CALC_FOUND_ROWS 최적화

### UNION 최적화

# 요약

최적화는 항상 세가지 접근 방식이 필요하다. 

바로 작업을 중단하고, 작업을 더 적게 수행하고, 작업을 더 빠르게 수행하는 것
