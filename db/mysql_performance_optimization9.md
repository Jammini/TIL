# 9장 복제

MySQL의 내장된 복제 기능은 ‘스케일 아웃’이라는 아키텍처를 사용하여 MySQL 위에 대규모 고성능 애플리케이션을 구축하는 기반이 된다.

복제를 통해 하나 이상의 서버를 다른 서버의 레플리카로 구성하여 데이터를 소스 복사본과 동기화할 수 있다.

이는 고성능 애플리케이션에 유용할 뿐만 아니라 고가용성, 확장성, 재해 복구, 백업, 분석, 데이터 웨어하우징 및 기타 수많은 작업을 위한 전략의 초석이기도 하다.

# 복제 개요

MySQL 복제는 대부분 이전 버전과 호환된다.

즉, 최신 서버 → 이전 서버의 레플리카 가능, 이전 버전의 서버 → 새 버전의 레플리카로 불가능 ex) MySQL 5.6 소스에서 MySQL 5.5 레플리카 복제 X

복제는 레플리카에 지정할 수 있는 읽기 확장에 비교적 적합하지만 올바르게 설계하지 않으면 쓰기를 확장하는 좋은 방법이 아니다. 많은 레플리카를 소스에 연결하면 각 레플리카에서 한 번씩 쓰기가 여러 번 수행된다.

일반 적인 복제 사용 방법

- 데이터분산
- 읽기 트래픽 확장
    - 읽기 쿼리를 여러 서버에 분산시킨다.
- 백업
- 분석 및 보고
- 고가용성 및 장애 조치
- MySQL 업그레이드 테스트

### 복제 작동 방식

1. 소스는 데이터의 변경 사항을 바이너리 로그에 ‘바이너리 로그 이벤트’로 기록한다.
2. 레플리카는 소스의 바이너리 로그 이벤트를 자체 로컬 릴레이 로그에 복사한다.
3. 레플리카는 릴레이 로그의 이벤트를 재생하여 자체 데이터에 변경 사항을 적용한다.

![image](https://github.com/Jammini/TIL/assets/59176149/400e6e89-195c-49d2-9eaf-f4b80999f9df)

레플리카에서 이벤트를 가져오고 재생하는 프로세스를 분리하여 이벤트를 동기화할 수 있다.

즉, I/O 스레드는 SQL스레드와 독립적으로 작동할 수 있다.

# 복제의 내부 동작

복제가 실제 어떻게 작동하는지 살펴보고 결과적으로 어떤 장단점이 있는지 확인한 후, 복제 구성을 위한 고급 옵션을 살펴보자.

### 복제 형식 선택

MySQL은 복제를 위한 명령문 기반, 행 기반, 혼합(명령문 + 행)의 세가지 바이너리 로그 형식을 제공한다.

1. 명령문 기반 복제
- 소스에서 데이터를 변경한 쿼리를 기록하여 작동한다. 레플리카가 릴레이 로그에서 이벤트를 읽고 실행할 때 소스가 실행한 실제 SQL 쿼리를 다시 실행한다.
- 주요 장점은 간단하고 컴팩트하다. 그러나 단점으로는 일반적으로 비결정적 쿼리 시 문제가 있다는 것이다.
    - ex) ORDER BY 절이 없는 1000행 테이블의 100행을 삭제하는 명령문인 경우, 소스와 레플리카 간에 행 순서가 다른 경우, 각기 다른 100개의 행을 삭제하면 불일치가 발생할 수 있다.
1. 행 기반 복제
- 행이 어떻게 변경되었는지 나타내는 이벤트를 바이너리 로그에 기록한다. 행 기반에서는 바이너리 로그를 보고 정확힌 어떤 행이 변경되었고 값이 어떻게 바뀌었는지 확인할 수 있다.
- 행 기반의 단점은 영향을 받는 모든 행에 대해 행 데이터 변경에 대한 이벤트를 작성하면 바이너리 로그의 크기가 크게 증가할 수 있다는 것이다.
1. 혼합 방식 복제
- 명령문 기반 형식을 기본값으로 사용하고 필요할 때만 행 기반 형식으로 전환하여 두 방식의 장점을 결합하려고 시도한다. 각 항목을 언제 쓸지에 대해 충족해야 하는 많은 조건이 있고 이로 인해 바이너리 로그에 예측할 수 없는 이벤트가 발생하기 때문이다.

일시적으로 명령문 기반을 사용해야 하는 경우가 아니면 행 기반 복제가 가장 안전한 방법을 제공한다.

### 전역 트랜잭션 식별자

MySQL 5.6 버전까지 레플리카는 소스에 연결할 때 읽고 있던 바이너리 로그 파일과 로그 위치를 추적해야 했다.

복제 위치를 추적하는 것이 상당히 복잡한 프로세스였으나 대체 방법인 GTID(전역 트랜잭션 식별자)를 추가하였다.

server_uuid와 증가하는 트랜잭션 번호의 조합으로 트랜잭션이 바이너리 로그에 기록되면 GTID도 기록된다.

SQL스레드는 트랜잭션을 커밋할 때 GTID도 완료된 것을 기록한다.

ex) 

1. 소스 서버에서 server_uuid b9acads-asdfsad-asdfasdfsd 생성되었다.
2. 레플리카가 복제에 소스 서버를 사용하도록 했다.
3. 소스 서버에 CREATE DATABASE misc;를 생성했다
4. 바이너리 로그에 기록되므로 레플리카도 DB를 생성할 수 있다. 바이너리 로그에서 GTID로 식별되는 단일 이벤트를 볼 수 있다.
5. 레플리카 서버는 이벤트를 적용하면서 b9acads-asdfsad-asdfasdfsd:1 트랜잭션 완료했음을 기록

이 시점에 레플리카에서 MySQL을 중지 한다면?

단일 트랜잭션으로 계속해서 소스에 쓰기를 수행하면 트랜잭션 목록이 2,3,4,5 등 계속 늘어난다.

레플리카를 다시 살렸을때, 레플리카는 트랜잭션 1은 이미 확인됐고 2를 처리할 수 있다.

### 복제 충돌의 대비

복제가 중단될 가능성을 최소화하려면 다음과 같이 설정하는 것이 좋다.

- innodb_flush_log_at_trx_commit = 1
    - 각 트랜잭션에서 로그를 기록하고 디스크에 동기화 할 수 있는 설정.
- sync_binlog = 1
    - MySQL이 바이너리 로그 데이터를 디스크에 동기화하는 빈도를 제어하는 설정.
- relay_log_info_repository = TABLE
    - MySQL 자체 내의 InnoDB테이블로 옮겨져 레플리카에서 동일 트랜잭션 내의 트랜잭션과 릴레이 로그 정보를 모두 업데이트 할 수 있다.
- relay_log_recovery = ON
    - 충돌이 감지되면 모든 로컬 릴레이 로그를 제거하고 소스에서 누락된 데이터를 가져온다.

### 지연 복제

많은 양의 데이터로 작업 중이고 실수로 테이블 삭제와 같은 변경이 발생했다고 하자.

시간 지연 레플리카를 사용하면 DROP TABLE 문의 GTID를 찾아 해당 테이블이 삭제되기 직전까지 복제를 따라 잡을 수 있다. 이로 인해 교정 시간이 훨씬 더 빨라질 수 있다.

지연복제는 특정 데이터 손실을 완화하는데 매우 유용하지만 다른 많은 운영 측면에서 복잡성을 초래한다.

### 멀티 스레드 복제

최신 MySQL 버전은 멀티 스레드 복제를 제공하여 멀티 SQL 적용 스레드를 실행하여 릴레이 로그의 변경 사항을 로컬로 적용할 수 있다.

![image](https://github.com/Jammini/TIL/assets/59176149/3bdadbc1-36ed-4c1c-a974-2f28826697d2)

멀티 스레드 복제는 두가지 모드가 존재한다.

1. DATABASE 
- 여러 스레드를 사용하여 서로 다른 데이터 베이스를 업데이트. 두 개의 스레드가 동시에 동일한 데이터베이스를 업데이트하지 않는다.
- MySQL의 여러 데이터베이스에 데이터가 분산되어 있고 일관성 있게 동시 업데이트하는 경우 적합
2. LOGICAL_CLOCK
- 동일한 바이너리 로그 그룹 커밋 단위로 동일 데이터 베이스에 대한 병렬 업데이트를 수행한다.

### 반동기 복제

소스가 커밋하는 모든 트랜잭션은 하나 이상의 레플리카에서 수신된 것으로 확인되어야 한다. 증명 방법은 레플리카가 이를 수신하고 자신의 릴레이 로그에 성공적으로 기록했음을 확인하는 것이다. (로컬데이터에 적용할 필요 X)

각 트랜잭션은 다른 노드의 응답을 기다려야 하므로 이 기능은 서버가 수행하는 모든 트랜잭션에 대기 시간을 추가한다.

만약, 일정 기간 동안 트랜잭션을 승인하는 레플리카가 없으면 MySQL은 표준 비동기식 복제로 되돌아 간다.

### 복제 필터

복제 필터링 옵션을 사용하면 서버 데이터의 일부만 복제할 수 있으나 이는 큰 이점이 아니다.

소스의 바이너리 로그에서 이벤트를 필터링하는 필터와 레플리카의 릴레이 로그에서 이벤트를 필텅하는 필터의 두 종류가 있다.

# 복제 페일오버

레플리카를 소스 역할로 승격시키는 작업을 페일오버라고 한다. 이것이 올바르게 수행되는 것이 얼마나 중요한지를 고려하여 최소한을 살펴보자.

### 계획된 승격

일반적으로 승격은 보안 패치, 커널 업데이트, 재시작을 해야 하는 몇가지 구성 옵션으로 인한 MySQL 재시작 등 일종의 유지 관리 이벤트로 인해 수행된다.

이 승격을 성공적으로 처리하기 위해 다음 단계를 수행한다.

1. 승격할 레플리카를 결정한다. 대개 모든 데이터가 있다고 확신하는 레플리카가 그 대상이 된다.
2. 몇 초 이내인지 확인하기 위해 지연을 확인한다.
3. super_read_only 를 설정하여 소스에 쓰기를 중지한다.
4. 복제가 대상과 동기화될 때까지 기다린다. GTID를 비교하여 확인해라.
5. 대상에서 read_only 설정을 해제한다.
6. 애플리케이션 트래픽을 대상으로 향하게 한다.
7. 강등된 래플리카를 포함하여 모든 레플리카를 새 소스로 다시 지정한다. GTID 및 AUTO_POSITION=1로 간단히 된다.

### 계획되지 않은 승격

쓰기가 발생하는 소스 서버에서 문제가 발생하면 사용자 경험에 큰 영향을 미칠 수 있다. 대부분 애플리케이션은 오류를 반환하고 사용자가 직접 재시도하도록 한다.

확인할 라이브 소스가 없으므로 이미 복제된 데이터를 기준으로 레플리카를 선택하는 간소화되고 계획된 승격이다.

1. 승격할 레플리카를 결정한다. 대개 모든 데이터가 있다고 확신하는 레플리카가 그 대상이 된다.
2. 대상에서 read_only 설정을 해제한다.
3. 애플리케이션 트래픽을 대상으로 향하게 한다.
4. 서비스가 재개될 때 강등된 레플리카를 포함하여 모든 레플리카를 새 소스로 다시 지정한다. GTID로 간단히 처리된다.

이전 소스가 다시 온라인 상태가 되었을 때 기본적으로 super_read_only가 활성화되어 있는지 체크해서 실수로 쓰는 것을 방지해라.

### 승격의 트레이드 오프

다운타임이 되더라고 페일오버를 첫번째 대응으로 생각하지 말아라. 대상에서 누락된 데이터의 양을 파악하는 것이 더 어렵기 때문에 페일오버를 하지 않는 것이 더 좋은 전략이 될 수 있다.

ACID 준수 단계를 따랐다면 데이터가 손실되지 않고 레플리카가 중단된 부분부터 다시 복구할 수 있다는 것이다.

# 복제 토폴로지

권장하는 두가지 전략

## 액티브/패시브(Active/Passive)

액티브/패시브 토폴로지에서는 모든 읽기 및 쓰기를 단일 소스 서버로 보낸다. 또한 애플리케이션 트래픽을 능동적으로 처리하지 않는 소수의 패시브 레플리카를 유지 관리한다. 복제 연에 대해 신경쓰고 싶지 않을때 이 모델을 주로 선택한다.

모든 읽기가 소스로 이동하므로 애플리케이션에서 원치 않는 쓰기 후 읽기 문제를 방지할 수 있다.

![image](https://github.com/Jammini/TIL/assets/59176149/6cefa5fc-73e9-40e6-96ea-eb2357dcff23)

### 구성

이 토폴로지에서는 소스와 레플리카가 CPU, 메모리 등의 측면에서 동일할 것. 레플리카에서 동일한 하드웨어 및 소프트 웨어 구성을 사용하면 페일오버 전과 같이 트래픽 용량과 처리량을 유지할 수 있다.

### 중복성

물리적 하드웨어 환경에서는 최소 3개의 총 서버에 대해 n+2 중복이 필요하다. 하드웨어 장애가 발생한 경우에도 페일오버를 위한 추가 서버가 하나 더 있어야 한다. 원본에서 백업을 수행할 수 없거나 불편할 경우 레플리카중 하나를 백업 서버로 사용할 수도 있다.

클라우드 환경에서는 데이터가 충분히 작거나 데이터를 쉽게 복사할 수 있는 경우, 총 2대의 서버에 대해 n+1 중복을 해결할 수 있다. 그렇지 않으면 n+2가 필요하다. → n+1을 선택하면 클라우드 공급자의 동적 프로비저닝 특성으올 인해 쉽게 관리할 수 있다.

목표는 레플리카가 페일 오버의 대상이 될 수 있게 항상 준비하는 것.

### 주의 사항

이 모델을 선택하면 읽기 확장을 단일 서버의 용량에 명시적으로 바인딩하는 것이다. 읽기 확장 제한에 도달하면 이 토폴로지 이상으로 발전하거나 샤딩을 활용하여 소스에서 읽기를 중여햐 한다.

## 액티브/리드 풀

액티브/리드 풀 구성에서는 모든 쓰기를 소스로 보낸다. 읽기는 애플리케이션 요구 사항에 따라 원본 서버나 리드 풀로 보낼 수 있다. 리드 풀을 사용하면 읽기 집약적인 애플리케이션은 읽기를 수평으로 확장할 수 있다.

![image](https://github.com/Jammini/TIL/assets/59176149/15548d3a-a4ba-469b-b89d-3aeed10e8a5c)

### 구성

원본과 리드 풀에 있는 하나 이상(가급적 두 개)의 레플리카 간에 구성을 동일하게 하는 것이 이상적이다.

### 중복성

하나 이상의 서버가 페일오버 대상으로 작동할 수 있다. 그 외에도 읽기 트래픽을 수용할 수 있는 충분한 노드와 노드 장애에 대비한 작은 버퍼가 필요하다.

읽기의 경우 CPU 사용률 지표가 가장 유력하며 풀의 노드당 사용률 50% - 60% 사이로 목표를 설정한다.

CPU가 증가할수록 작업과 지연 시간 사이의 컨텍스트 전황에 더 많은 시간이 소요된다.

지연시간과 사용률 사이에서 애플리케이션 기대치를 충족하는 적절한 규형을 찾아라.

### 주의 사항

리드 풀을 사용할 땨는 애플리케이션은 스테일 리드(소스의 최신 상태가 반영되지 않은 데이터를 읽는것)를 어느정도 허용해야 한다.

소스에서 완료한 쓰기가 이미 레플리카에 복제되었는지 보장할 수 없다.

## 권장 하지 않는 토폴로지

### 액티브-액티브 모드의 이중소스

이중 소스 복제(양방향 복제)는 각각 소스와 다른 서버의 레플리카, 즉 한 쌍의 공동소스로 구성된 두 대의 서버로 이우러진다.

![image](https://github.com/Jammini/TIL/assets/59176149/cff7935f-bb88-4fdc-b915-91bd20d3795e)

액티브/액티브는 올바르게 수행하기가 매우 어렵다. 이렇게 하면 동일한 행에 대해 쓰기 후 읽기 작업이 일관 되지만 다른 쪽에 그 행이 포함된 쿼리는 일관되지 않을 수 있다. 복제 지연으로 인해 반영되지 않는 업데이트가 다른 쪽에 있으면 그럴 것이다.

결국, 애플리케이션에 데이터 불일치를 초래하게 되고 페일오버할 용량이 부족한 상황을 마주할 수 있다.

### 액티브-패시브 모드의 이중 소스

![image](https://github.com/Jammini/TIL/assets/59176149/cb4b1c23-c629-446f-b56a-854c8f1d187f)

액티브/패시브 권장사항과 다른 유일한 점은 복제가 다른 유일한 점은 복제가 다른 서버로 미리 구성되었다는 것이다. 이것은 2개의 서버 구성에서만 작동한다.

서버를 두 대이상 실행하는 경우, 페일오버의 가장 적합한 대상을 결정해야 한다. 복제를 사전 구성하면 하나의 복제에만 직접 연결할 수 있으며 이는 운영 중단 상황에서 유연성을 제공하지 않는다.

### 레플리카가 있는 이중 소스

![image](https://github.com/Jammini/TIL/assets/59176149/e55a154e-b790-4a3c-b04c-b7657c4f542a)

이것은 액티브-액티브 상태에서 이중 소스로 생기는 대부분 문제를 유지하며 가장 중요한것은 트래픽을 라우팅하는 방법이다. 이 구성은 페일오버시 용량 계획 및 버퍼 풀전환에 대한 문제를 해결한다.

주로 데이터 액세스 문제에 대한 우려로 이 안 또한 추천하지 않는다. 공동 소스는 문제를 일으킨다.

### 링 복제

각 서버가 링에 있는 앞선 서버의 레플리카고 뒤에 있는 서버의 원본인 세 개 이상의 소스가 있다. 이 토폴로지를 순환 복제라고도 한다,

![image](https://github.com/Jammini/TIL/assets/59176149/e2ed60e7-45b6-4532-baa1-d183025e8516)

이 토폴로지의 어떤 서버라도 오프라인으로 전환되면 토폴로지가 손상되고 링의 업데이트 흐름이 중지된다.

소스에 스왑할 전용 레플리카가 있는 첨부된 레플리카 변형이 있다. 따라서, 레플리카를 이전 위치로 승격할 때 까지 링이 끊어진다.

### 다중 소스 복제

![image](https://github.com/Jammini/TIL/assets/59176149/df4a589e-0c4e-4600-95b7-860391da64fc)

이 토폴로지는 특수 사용환경에 매우 적합하다. 데이터를 병합하기 위해 임시로 사용하는 것은 두가지 권장 사항중 하나로 되돌리는 것이 최종 목표일 때만 허용되는 사용사례이다.

영구 토폴로지를 구축하는 경우에는 권장하지 않는다.

# 복제 관리 및 유지관리

대부분 데이터 베이스는 시간이 지남에 따라 크기가 커지는 경향이 있으며 그 증가와 함께 유지 관리가 필요하다.

### 복제 모니터링

복제 모니터링을 설정할 때 가장 중요하게 고려해야 하는 몇가지 항목이 있다.

1. 복제는 소스에 레플리카 모두 디스크 공간이 필요하다
    - 소스의 바이너리 로그와 레플리카의 릴레이 로그를 모두 사용한다. 사용가능한 디스크 공간에 대해 모니터링하고 싶을 것이다.
2. 복제 상태 및 오류를 모니터링해야 한다.
    - 네트워크 문제, 데이터 불일치, 데이터 손상과 같은 외부 요인으로 인행 복제가 중단될 수 있다. 따라서, 복제 스레드가 실행중인지 여부를 모니터링하고 실행중이 아닌 경우 오류가 무엇인지 살펴보고 다음 단계를 결정하는 것이 좋다.
3. 지연된 복제는 예상대로 지연되어야 한다.
    - 지연된 레플리카가 실제로 정확한 시간만큼 지연되도록 모니터링을 설정하는 것이 좋다.

### 복제 지연 측정

모니터링해야 하는 가장 일반적인 사항 중 하나는 레플리카가 실행중인 소스보다 얼마나 뒤떨어지는지 이다.

SHOW REPLICA STATUS의 Seconds_behind_source 열은 이론적으로 레플리카의 지연을 보여주지만, 여러가지 이유로 항상 정확하지는 않는다.

- 레플리카는 서버의 현재 타임스탬프와 바이너리 로그 이벤트에 기록된 타임스탬프를 비교하여 Seconss_behind_source를 계산하므로 쿼리를 처리하지 않는 한 지연을 보고할 수도 없다.

이러한 문제에 대한 해결책은 Seconds_behind_source을 무시하고 직접 관찰하고 측정할 수 있는 레플리카 지연을 모니터링하는 것이다.

### 레플리카와 소스의 일치 여부 확인

이러한 문제에 대한 해결책은 Seconds_behind_source을 무시하고 직접 관찰하고 측정할 수 있는 레플리카 지연을 모니터링하는 것이다.

### 레플리카와 소스의 일치 여부 확인

레플리카는 복제 지연을 제외하면 항상 원본의 정확한 복사본이다. 하지만 불일치가 레플리카에 존재할 수 있다. 몇가지 가능한 원인은 다음과 같다.

- 레플리카에 실수로 쓰기
- 양쪽이 쓰기를 수행하는 이중 소스 복제 사용
- 비결정적 쿼리 및 명령문 기반 복제
- 지속성이 낮은 모드에서 실행하는 동안 MySQL의 충돌
- MySQL의 버그

이렇게 불일치 문제의 원인을 제거하기 위해 다음과 같은 규칙을 제안한다.

1. 항상 super_read_only가 활성화된 상태에서 레플리카 실행
2. 행 기반 복제 또는 결정론적 구문 사용
3. 복제 토폴로지의 여러 서버에 동시에 쓰지 않기

# 복제 문제와 해법

### 소스의 바이너리 로그 손상

소스의 바이너리 로그가 손상되었다면 레플리카를 재구성하는 것 외에는 다른 방법이 없다. 손상된 항목을 건너뛰면 레플리카에서 더 이상 처리하지 않는 일부 트랜잭션을 건너뛴다.

### 고유하지 않은 서버 ID

가장 어려운 문제중 하다. 실수로 동일한 서버 ID로 두개의 레플리카를 구성한 경우 자세히 보지 않으면 제대로 작동하는 것처럼 보일 수 있다.

레플리카를 설정할 때 주의해라. 각 레플리카에 속한 ID를 추적하지 않도록 레플리카 - 서버ID 매핑의 표준 목록을 만드는 것이 도움이 될 수 있다. 레플리카가 완전히 하나의 네트워크 서브넷 내에 있는 경우 각 IP 주소의 마지막 옥텟을 사용하여 고유한 ID를 선택할 수 있다.

### 정의되지 않은 서버 ID

서버ID를 정의하지 않으면 MySQL이 복제를 설정하는 것처럼 보이지만 레플리카를 시작할 수 없다.

값을 명시적으로 설정해야 한다

### 임시 테이블 누락

일부 용도에 유용하지만, 명령문 기반 복제와 호환되지 않는다. 레플리카가 충돌하거나 종료하면 레플리카 스레드에서 사용하던 임시테이블이 사라진다. 레플리카를 재시작할 때 누락된 임시 테이블을 참조하는 추가 명령문은 실패한다.

행기반 복제를 사용하고, 임시테이블의 이름을 일관되게 지정하고 복제 규칙을 사용하여 테이블의 복제를 완전히 건너뛰는것이다.

### 모든 업데이트를 복제하지 않음

SET SQL_LOG_BIN을 오용하거나 복제 필터링 규칙을 이해하지 못하면 레플리카가 소스에서 발생한 일부 업데이트를 실행하지 못할 수 있다. 

### 과도한 복제 지연

어떤 경우에도 레플리카에서 약간의 지연을 허용하도록 애플리케이션을 설계하는 것이 좋다. 복제 지연을 줄이기 위한 일반적인 접근 방식은 다음과 같다.

- 멀티 스레드 복제
- 샤딩 사용
    - 여러 소스에 쓰기를 분산하는 것은 매우 효과적인 전략이다. 레플리카로 읽기 화장, 샤딩으로 쓰기 확장
- 일시적인 지속성 저하
    - sync_binding=0 및 innodb_flush_log_at_trx_commit=0을 설정하여 복제 속도를 높일 수 있다.

마지막 방법은 레플리카에서만 작업을 수행해야 한다. 모니터링 상태가 양호한지 확인하거나 지속성을 다시 설정하는 방법을 작성했는지 확인해라.

1. super_read_only가 활성화되어 있는지 확인하여 서버가 쓰기 불가능한 레플리카 인지 확인한다.
2. sync_binding 및 innodb_flush_log_at_trx_commit에 대한 설정을 변경하여 쓰기 작업을 줄인다.
3. SHOPW REPLICA STATUS에서 Seconds_behind_source 값을 주지적으로 확인한다.
4. 허용 임곗값 미만으로 설정으로 되돌린다.

### 디스크 공간 없음

복제는 실제로 바이너리 로그, 릴레이 로그 또는 임시 파일로 디스크를 채울 수 있다. 레플리카가 뒤처질수록 소스에서 가져왔지만 아직 실행되지 않은 릴레이 로그에 더 많은 디스크 공간을 할애할 수 있다. 디스크 사용량을 모니터링하고 relay_log_space 구성 변수를 설정하여 이러한 오류를 방지할 수 있다.

### 요약

MySQL의 복제는 내장기능의 만능 도구이며 MySQL의 기능 범위와 유용성을 극적으로 증가시킨다.

복제는 단순함을 유지하는 것이 좋다. 복제를 사용하면 모든 권한을 포함하여 전체 데이터 복사본을 미러링할 수 있다. 레플리카를 모든 면에서 소스와 동일하게 유지하면 많은 문제를 방지할 수 있다.