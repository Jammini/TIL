# 카프카(kafka) 조금 아는척하기 - 1

### 목차

1. [개요](#1-개요)
2. [카프카란?](#2-카프카란)
3. [기본구조](#3-기본구조)
4. [토픽과 파티션](#4-토픽과-파티션)
5. [파티션과 오프셋, 메시지 순서](#5-파티션과-오프셋-메세지-순서)
6. [여러 파티션과 프로듀서](#6-여러-파티션과-프로듀서)
7. [여러 파티션과 컨슈머](#7-여러-파티션과-컨슈머)
8. [카프카와 성능](#8-카프카와-성능)
9. [리플리카 - 복제](#9-리플리카---복제)
10. [결론](#10-결론)

## 1. 개요

결제시스템 프로젝트를 진행하면서 카프카를 사용하였는데, 대략적인 내용만 알고 있어 카프카에 대한 정리가 필요하였다. 그래서 카프카에 대해 정리하기 위해 쉽게 정리된 내용이 없을까 하다가 최범균님의 ‘카프카 조금 아는 척하기’를 보게 되었고 그것에 대해 정리해서 익혀보려고한다.

## 2. 카프카란?

카프카의 공식사이트 https://kafka.apache.org/ 를 들어가보면 아래와 같은 그림이 나온다.

<img width="758" alt="image" src="https://github.com/Jammini/TIL/assets/59176149/5fecc72b-0179-48d8-93c2-6e7d7b58c2e4">

카프카는 분산 이벤트 스트리밍 플랫폼(distributed event streaming platform)으로 소개하고 있으며 고성능(high-performance)를 강조하고 있는 것을 볼 수 있다.

이처럼 대기업 기준 80% 이상이 사용하고 있고 다양한 업종에서 카프카를 사용하고 있다고 한다. 국내에서도 카프카는 많은 기업에서도 현재 사용하고 있다.

## 3. 기본구조

<img width="782" alt="image" src="https://github.com/Jammini/TIL/assets/59176149/3824bea4-fbba-40e4-958b-74ff7f6757a1">

카프카는 크게 4개의 구성요소가 있다.

1. 카프카 클러스터 : 메세지(이벤트)를 저장하는 저장소.
    - 하나의 카프카 클러스터는 여러개의 브로커로 이루어져있는데 이 브로커를 각각의 서버로 보면 된다.
    - 브로커들이 메세지를 나눠서 저장하고 이중화 처리도 하고 장애가 나면 대체도 하는 역할을 한다.
2. 주키퍼 : 카프카 클러스터 관리.
    - 카프카 클러스터와 관련된 내용이 기록되고 관리된다.
3. 프로듀서(Producer) : 카프카 클러스터에 메세지를 보내는 역할.
4. 컨슈머(Consumer) : 메세지를 카프카에서 읽음.

## 4. 토픽과 파티션

**토픽 : 메세지를 구분하는 단위 → 파일시스템의 폴더와 유사**

**파티션 : 메세지를 저장하는 물리적인 파일**

한 개의 토픽은 한 개 이상의 파티션으로 구성

<img width="750" alt="image" src="https://github.com/Jammini/TIL/assets/59176149/aa56a6f1-0115-4dae-8297-c383c3be96a4">

프로듀서와 컨슈머는 토픽을 기준으로 메세지를 주고 받는다.

## 5. 파티션과 오프셋, 메세지 순서

- 파티션은 추가만 가능한(apped-only) 파일이다.
- 각 메세지 저장 위치를 오프셋(offset)이라고 한다.
- 프로듀서가 넣은 메세지는 파티션의 맨 뒤에 추가한다.
- 컨슈머는 오프셋 기준으로 메시지를 순서대로 읽는다.
- 메세지는 삭제되지 않는다.(설정에 따라 일정 시간이 지난 뒤 삭제) → 컨슈머가 읽어가도 파일이기에 메세지는 항상 보존된다.

<img width="749" alt="image" src="https://github.com/Jammini/TIL/assets/59176149/c183014a-26d8-442e-9517-715c627e55fe">

## 6. 여러 파티션과 프로듀서

- 프로듀서는 라운드로빈 또는 키로 파티션을 선택한다.
- 프로듀서가 카프카에 메세지를 전송할 때 토픽에 이름뿐만 아니라 키도 지정할 수 있는데, 키의 해시 값을 이용해 파티션을 선택할 수도 있다. → 즉, 같은 키를 가진 메세지는 같은 파티션에 저장되며 같은 키에 되해서는 순서 유지

<img width="724" alt="image" src="https://github.com/Jammini/TIL/assets/59176149/eb143b3f-dcb9-4e1f-9a9c-c2e32d2b258f">

## 7. 여러 파티션과 컨슈머

- 컨슈머는 컨슈머그룹에 속함
- 한 개 파티션은 컨슈머 그룹의 한 개 컨슈머만 연결 가능
    - 즉, 컨슈머 그룹에 속한 컨슈머들은 한 파티션을 공유할 수 없음
    - 한 컨슈머그룹 기준으로 파티션의 메세지는 순서대로 처리

<img width="729" alt="image" src="https://github.com/Jammini/TIL/assets/59176149/e201b952-a4c8-4f86-a289-c2842548369f">

## 8. 카프카와 성능

1. 파티션 파일은 OS 페이지캐시 사용
    - 파티션에 대한 파일 I/O를 메모리에서 처리하기에 빠르다.
    - 서버에서 페이지캐시를 카프카만 사용해야 성능에 유리하다.

2. Zero Copy

- 디스크 버퍼에서 네트워크 버퍼로 직접 데이터 복사
3. 컨슈머 추적을 위해 브로커가 하는 일이 비교적 단순
    - 메세지 필터, 메세지 재전송과 같은 일은 브로커가 하지 않고 프로듀서, 컨슈머가 직접한다.
    - 브로커는 컨슈머와 파티션간 매핑 관리
4. 묶어서 보내기, 묶어서 받기(batch)
    - 프로듀서 : 일정 크기만큼 메세지를 모아서 전송가능
    - 컨슈머 : 최소 크기만큼 메세지를 모아서 조회 가능
    - 낱개 처리보다 처리량 증가

<img width="762" alt="image" src="https://github.com/Jammini/TIL/assets/59176149/2008ea4a-3894-484f-a8b4-d32f963b479b">

5. 처리량 증대(수평 확장)가 쉬움
    - 1개 장비의 용량 한계 → 브로커 추가, 파티션 추가
    - 컨슈머가 느림 → 컨슈머 추가 (+ 파티션 추가)

<img width="779" alt="image" src="https://github.com/Jammini/TIL/assets/59176149/05493ea3-e086-4fd7-a2f2-151d79a1a64e">

## 9. 리플리카 - 복제

- 리플리카 : 파티션의 복제본
    - 복제수만큼 파티션의 복제본이 각 브로커에 생김
- 리더와 팔로워로 구성
    - 프로듀서와 컨슈머는 리더를 통해서만 메세지 처리
    - 팔로워는 리더로부터 복제
- 장애 대응
    - 리더가 속한 브로커 장애시 다른 팔로워가 리더가 됨.

<img width="754" alt="image" src="https://github.com/Jammini/TIL/assets/59176149/d588e0bc-9f8a-43f5-8dc1-d112dfc00d3b">


## 10. 결론

카프카는 성능적으로 매우 우수하다. 높은 처리량과 고가용성을 가지고 있다

- 성능(높은 처리량)
    - OS 페이지 캐시
    - (다른 메시징 시스템 대비) 단순한 브로커
    - 묶어서 데이터 전송
    - 파티션/컨슈머 추가로 수평확장
- 고가용성
    - 파티션 리플리케이션 + 리더/팔로워 구조

### 참고

- https://www.youtube.com/watch?v=0Ssx7jJJADI