# 패스워드 암호화를 어떤 방식으로 하면 좋을까?

### 목차

1. [개요](#1-개요)
2. [단방향 암호화 (One-Way Encryption)](#2-단방향-암호화-one-way-encryption)
3. [양방향 암호화 (Two-Way Encryption)](#3-양방향-암호화-two-way-encryption)
4. [해시함수란?](#4-해시함수란)
5. [MD5](#5-md5)
6. [SHA](#6-sha)
7. [왜 MD5와 SHA와 같은 방식으로 비밀번호를 암호화 하면 안될까?](#7-왜-md5와-sha와-같은-방식으로-비밀번호를-암호화-하면-안될까)
8. [Bcrypt란?](#8-bcrypt란)
9. [결론](#9-결론)

### 1. 개요

일반적으로 대부분의 사이트에서는 아이디와 비밀번호로 로그인을 하고 각각 개인정보들을 데이터베이스 저장을 한다.

이러한 개인정보 중 비밀번호와 같이 노출되어서는 안되는 종류들이 그대로 데이터베이스에 저장되면 어떻게 될까?

정답은 당연 문제가발생한다. 이러한 개인정보는 암호화해서 데이터베이스 저장응 해야하며 어떻게 패스워드를 암호화 하는 것이 좋을지 알아보자.

### 2. 단방향 암호화 (One-Way Encryption)

- **특징**
    - 단방향 암호화는 주로 비밀번호 저장과 같은 경우에 사용된다. 이 방법은 원본 데이터(예: 비밀번호)를 암호화된 형태로 변환하는데, 암호화된 데이터는 원본 데이터를 복원할 수 없는 방식으로 변환된다.
- **예시**
    - 가장 일반적인 예는 해시 함수를 사용하는 것이다. 해시 함수는 입력값을 고정 길이의 문자열로 변환한다. 동일한 입력에 대해서는 항상 동일한 해시 코드를 생성하지만, 해시 코드를 원래 입력으로 역추적하는 것은 매우 어려워야 한다. 대표적인 해시 함수로는 SHA-256, bcrypt, scrypt, PBKDF2 등이 존재한다.
- **용도**
    - 주로 사용자 비밀번호와 같은 민감한 데이터를 안전하게 저장할 때 사용된다. 사용자가 로그인할 때 입력한 비밀번호를 원본 비밀번호와 비교하는 대신, 입력된 비밀번호를 해시화하여 저장하고, 로그인 시에도 입력된 비밀번호를 다시 해시화하여 저장된 해시와 비교한다.

### 3. 양방향 암호화 (Two-Way Encryption)

- **특징**
    - 양방향 암호화는 데이터를 암호화할 때 사용되며, 암호화된 데이터를 원래의 형태로 복원할 수 있다. 즉, 암호화된 데이터를 다시 원본 데이터로 복원할 수 있어야 한다.
- **예시**
    - 가장 일반적인 예는 대칭 키 암호화이다. 대칭 키 암호화에서는 동일한 키가 데이터를 암호화하고 해독하는 데 사용된다. 대표적인 대칭 키 알고리즘으로는 AES(Advanced Encryption Standard)가 존재한다.
- **용도**
    - 주로 데이터를 안전하게 전송하거나 저장하기 위해 사용된다. 예를 들어, 데이터베이스 내의 민감한 정보를 암호화하거나, 데이터를 안전하게 전송하기 위해 HTTPS를 사용하는 경우에 양방향 암호화가 사용된다.

### 4. 해시함수란?

해시 함수는 값을 입력받아 고정된 길이의 해시값을 출력하는 함수로 같은 입력에 대해서는 항상 같은 출력이 나오지만 출력을 가지고 역으로 입력값을 도출할 수는 없는 특징을 가진다.

이러한 해시함수를 사용하는 목적은 메시지의 오류나 변조를 탐지할 수 있는 무결성을 제공하기 위해 사용된다.

- 특징
    - 어떤 입력 값에도 항상 고정된 길이의 해시값을 출력한다.
    - 입력 값의 아주 일부만 변경되어도 전혀 다른 결과 값을 출력한다.
    - 출력된 결과 값을 토대로 입력값을 유추할 수 없다.

### 5. MD5

MD5(MD5 Message-Digest Algorithm)는 해시 함수의 한 종류로, 주로 데이터의 무결성을 검증하기 위해 사용되었다. 그러나 현재는 보안적으로 취약한 알고리즘이므로, 민감한 정보를 안전하게 보호하는 데 사용해서는 안 된다.

### 6. SHA

SHA(안전한 해시 알고리즘, Secure Hash Algorithm)는 고정된 크기의 해시 값을 생성하기 위한 해시 함수 알고리즘의 집합이다.

SHA 알고리즘은 데이터 무결성 확인, 디지털 서명, 비밀번호 보호 및 다양한 보안 응용 프로그램에서 사용되는 무작위성을 가지고 있는 해시 함수를 의미한다.

각각의 SHA 버전은 서로 다른 크기의 해시 값을 생성하며, 더 높은 보안 수준을 위해 더 많은 연산을 수행한다.

1. SHA-1 (Secure Hash Algorithm 1)
    - 160비트(20바이트) 크기의 해시 값을 생성한다.
    - 이전에 많이 사용되었지만, 현재는 보안적으로 취약하다고 여겨진다. 충돌을 발생시키는 공격이 나타났기 때문에 권장되지 않고 있다.
2. SHA-256 (Secure Hash Algorithm 256)
    - 256비트(32바이트) 크기의 해시 값을 생성한다.
    - 안전한 해시 함수 중 하나로, 현재 많은 보안 응용 프로그램에서 사용된다. 데이터 무결성 검사, 디지털 서명, 비밀번호 보호 등에 사용된다.
3. SHA-3 (Secure Hash Algorithm 3)
    - SHA-3은 NIST(미국 국립 표준 기술 연구소)에 의해 표준으로 제정된 해시 함수이다.
    - 다양한 해시 크기를 지원하며, 보안성과 성능을 향상시킨 알고리즘을 제공한다.
4. SHA-512 (Secure Hash Algorithm 512)
    - 512비트(64바이트) 크기의 해시 값을 생성한다.
    - SHA-256보다 더 강력한 보안을 제공하며, 더 많은 연산을 필요로 한다.

### 7. 왜 MD5와 SHA와 같은 방식으로 비밀번호를 암호화 하면 안될까?

1. 솔트(Salt) 미사용
    - 해시 함수로 비밀번호를 암호화할 때 솔트(Salt)를 사용하지 않으면, 동일한 비밀번호는 항상 동일한 해시 값으로 변환된다. 이는 레인보우 테이블(해커들이 여러 값들을 대입해보면서 얻었던 다이제스트들을 모아놓은 리스트) 공격과 같은 공격에 취약하게 만든다. 솔트는 각각의 사용자 또는 비밀번호에 대해 고유한 값을 추가하여 동일한 비밀번호에 대해 다른 해시를 생성하도록 한다.
2. 빠른 해시 계산
    - SHA, MD5와 같은 일반적인 해시 함수는 빠른 계산을 위해 설계되었다. 이는 공격자가 빠르게 다양한 비밀번호 후보를 시도하고 무차별 대입 공격을 수행하는 데 도움이 된다. 비밀번호를 보호하기 위해서는 연산을 복잡하게 만들어야 한다.
3. 충돌 가능성
    - MD5와 SHA-1은 충돌 가능성이 높아서, 서로 다른 입력에 대해 동일한 해시 값을 생성할 가능성이 높다. 이는 공격자가 충돌을 활용하여 비밀번호를 추측하는 데 사용할 수 있다.
4. 약한 보안
    - MD5와 SHA-1은 현재는 보안 취약점이 발견되어 보안 커뮤니티에서 권장되지 않는다.

### 8. Bcrypt란?

BCrypt는 비밀번호 해싱과 비밀번호 저장에 사용되는 해시 함수 및 암호화 라이브러리이다.

비밀번호 보안을 강화하기 위해 설계된 강력한 알고리즘으로, 주로 웹 애플리케이션 및 인증 시스템에서 사용된다.

- 특징
    - 솔트(Salt) 사용: 각 비밀번호에 대해 무작위 솔트 값을 생성하여 원본 비밀번호와 결합한다. 이로써 동일한 비밀번호에 대해 항상 다른 해시 값을 생성하게 되어 레인보우 테이블 공격과 같은 공격을 방지한다.
    - 고비용 연산: 무작위 솔트와 함께 원본 비밀번호를 여러 번 해싱하는 것을 허용한다. 이를 통해 공격자가 무차별 대입 공격을 수행하기 어렵게 만든다. 연산 횟수는 원본 비밀번호를 해싱할 때 조절 가능하며, 더 많은 연산은 공격자에게 시간을 더 많이 낭비시킨다.
    - 안전한 해시 함수: 안전한 해시 함수로 알려진 Blowfish 해시 함수를 기반으로 한다. 이 해시 함수는 안전한 해싱을 제공한다.
    - 상호 호환성: 많은 프로그래밍 언어와 라이브러리에서 사용할 수 있으며, 다른 BCrypt 구현과 상호 호환성을 제공하는 경우가 많다.
- 예시

해커가 Output(Digest) 값을 탈취한 상태라로 가정하도록 하자.

사용자의 패스워드 ”AAA”를 일반적인 해시 함수를 사용해 암호화 한다면 다음 그림과 같다.

![image](https://github.com/Jammini/TIL/assets/59176149/495e82fc-fc39-4fc2-92e7-60d14b13fee4)

해커는 이제 무작위로 값을 넣어 드디어 찾아내야 한다.

**Bcrypt 해시 알고리즘은 여기에 아래와 같이 전처리 과정(Salt)와 반복횟수를 더한다.**

![image](https://github.com/Jammini/TIL/assets/59176149/c1b64db5-dfb0-4873-b9ae-bea5034a10b0)

이렇게 하게 되면 이제 해커는 Output(Digest)만을 가지고 패스워드를 찾아낼 수 없다.

![image](https://github.com/Jammini/TIL/assets/59176149/17d9e34f-9509-4e8d-a059-548267f1e5a4)

식별자를 포함하여 앞의 세자리 중 두자리(2a)는 해시 알고리즘 식별자라는 것을 파악했고 cost factor로 반복 횟수도 확인했고...

반복 횟수가 1백만번 + 랜덤 솔트 Bcrypt 해시 알고리즘에는 반복횟수(Key Stretching)를 변수로 지정하여 작업량을 늘리기 때문에 해커는 해킹하는데 엄청 오랜 시간이 걸린다는 것을 파악했다.

Bcrypt는 이런식으로 패스워드를 지키는 알고리즘으로 다른 알고리즘에 비해 상대적으로 안전하다고 할 수 있다.

### 9. 결론

- Bcrypt 해시 함수 알고리즘을 사용한 패스워드 암호화는 단순히 해시 함수를 통함 암호화만을 지원하는 것은 아니다.
- 해커에게 모든 정보가 노출되었을 경우, 패스워드를 안전하게 지키기 위해 막대한 전처리 요구(salt)와 반복 횟수(count)를 변수로 지정하여 작업량 늘려 패스워드를 찾기 힘들도록 강제할 수 있다.
- BCrypt는 비밀번호 보안을 강화하고, 무력한 공격에 대한 방어를 제공하는 강력한 도구로서 널리 사용된다. 따라서 보안 응용 프로그램에서 비밀번호를 저장할 때 BCrypt를 사용하는 것이 권장된다.

### 참고

- https://als2019.tistory.com/86
- https://st-lab.tistory.com/100
