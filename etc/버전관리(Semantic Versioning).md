# 버전관리(Semantic Versioning)

정해진 규칙없이 제각각의 방식으로 관리하지 않고 규칙을 정해서 관리하기 위해 Github의 공동창업자인 **[Tom Preston-Werner](https://tom.preston-werner.com/)** 가 제안 하였습니다.

Semantic Versioning 을 예로 먼저 살펴보자.

```
2.1.1
Major.Minor.Patch
```

애플리케이션이나 프로그램 버전과 같이 익숙한 모습이 보일 것이다.

### 일반적인 규칙

1. 버전 번호는 Major, Minor, Patch 의 형태로 배포하고, Major, Minor, Patch 는 각각 자연수이고 절대 앞에 0이 붙어서는 안된다.
2. 각 번호의 수는 항상 증가해야 한다.
3. 특정 버전으로 패키지를 배포하고 나면, 그 버전의 내용은 절대 변경하지 말아야 한다. 변경분이 있다면 반드시 새로운 버전으로 배포하도록 한다.
4. Major 버전이 변경될 때, Minor, Patch는 0으로 초기화 된다.
5. Minor 버전이 변경이 될 때, Patch 는 0으로 초기화 된다.

### Major 버전 증가

- 하위 버전과 호환되지 않는 변화가 생겼을 때
- 대대적인 변화가 일어났을 때
- 클라이언트가 1.0.0 버전의 API 접근 방식으로 2.0.0 버전에 접속할 수 없을 때

### Minor 버전 증가

- 하위 버전과 호환이 되면서, 새로운 기능이 추가 될 때
- 새로운 기능이 추가된 API 가 나왔지만, 기존의 공개된 API 가 하위 호환되고 있을 때
- 기존의 기능이 변경되거나 사용 방법이 변경 되었을 때

### Patch 버전 증가

- 버그 수정
- 기존 클라이언트가 알아차리지 못할 정도의 작은 변화가 있을 때
- 서버 코드 내부적으로 소스가 수정되었을 때
- 당연한 얘기겠지만, 이 모든 것들이 하위 버전과 호환될 때

### 간단하게 정의하면?

Major(전체를 뒤엎을 변화). Minor(기능 추가 및 수정). Patch(버그 및 내부 코드 수정) 

추가적으로 여러 규칙들이 존재하지만 자세한 사항은 아래의 사이트에서 살펴보길 바란다.

[https://semver.org/lang/ko/](https://semver.org/lang/ko/)
