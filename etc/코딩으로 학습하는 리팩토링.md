# 코딩으로 학습하는 리팩토링

인프런 **[코딩으로 학습하는 리팩토링](https://www.inflearn.com/course/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/dashboard)** 내용을 바탕으로 정리 하였습니다.


## 리팩토링(Refactoring)

- 처음부터 완벽하게 시스템을 설계하는 것은 매우 어려운 일.
- 이미 코드를 작성한 이후에 구조를 변경하는 일이 발생.
- 리팩토링으로 애플리케이션 구조를 꾸준히 개선해 나가야 함.
- 구조 변경으로 인한 버그를 줄이면서 코드를 깔끔하게 유지할 수 있는 방법

## 참고 문헌

<img width="239" alt="Image" src="https://github.com/user-attachments/assets/1d837118-7182-4f53-a6be-0e9e19882f1b" />

- 리팩토링 기술을 분류별로 되어 있음
    - 기본기술
    - 캡슐화 관련 기술
    - API 관련 기술
    - 상속 관련 기술 등

## 코드에서 나는 악취

1. [기이한 이름 (Mysterius Name)](#냄새-1-기이한-이름)
2. [중복 코드 (Duplicated Code)](#냄새-2-중복코드)
3. [긴 함수 (Long Function)](#냄새-3-긴-함수-long-function)
4. [긴 매개변수 목록 (Long Parameter List)](#냄새-4-긴-매개변수-목록-long-parameter-list)
5. [전역 데이터 (Global Data)](#냄새-5-전역-데이터-global-data)
6. 가변 데이터
7. 뒤엉킨 변경
8. 산탄총 수술
9. 기능 편애
10. 데이터 뭉치
11. 기본형 집착
12. 반복되는 switch문
13. 반복문
14. 성의 없는 요소
15. 추측성 일반화
16. 임시 필드
17. 메시지 체인
18. 중개자
19. 내부자 거래
20. 거대한 클래스
21. 서로 다른 인터페이스의 대안 클래스들
22. 데이터 클래스
23. 상속 포기
24. 주석

리팩토링을 하려면 **리팩토링을 하고 싶은 코드를 찾아야한다.** 그러기 위해서 이 책에서는 냄새라고 표현한다.

## 냄새 1. 기이한 이름 (Mysterius Name)

- 깔끔한 코드에서 가장 중요한 것 중 하나가 바로 “좋은 이름”이다.
- 함수, 변수, 클래스, 모듈의 이름 등 모두 어떤 역할을 하는지 어떻게 쓰이는지 직관적이어야 한다.
- 사용할 수 있는 리팩토링 기술
    1. 함수 선언 변경하기 (Change Function Declaration)
    2. 변수 이름 바꾸기 (Rename Variable)
    3. 필드 이름 바꾸기 (Rename Field)

### 1. 함수 선언 변경하기 (Change Function Declaration)

- 좋은 이름을 가진 함수는 함수가 어떻게 구현되었는지 코드를 보지 않아도 이름만 보고도 이해할 수 있다.
- 좋은 이름을 찾아내는 방법? 함수에 주석을 작성한 다음, 주석을 함수 이름으로 만들어 본다
- 함수의 매개변수는
    - 함수 내부의 문맥을 결정한다. (ex, 전화번호 포매팅 함수)
    - 의존성을 결정한다. (ex, Payment 만기일 계산 함수)

**before**

<img width="705" alt="Image" src="https://github.com/user-attachments/assets/a7503a54-3ccc-41f6-8181-630b100c768e" />

기존 코드에 `studyReviews`라는 함수를 보면 Github issue 에서 스터디 리뷰 이슈에 작성되어 있는 리뷰어 목록과 리뷰를 읽어오는 역할을 한다.

그렇다면 좋은 이름을 바꾸는데 있어서 코드를 일일이 바꾸는건 시간적으로나 효율성으로나 굉장히 떨어진다.

그래서 우리는 보통 IDE의 도움을 받아서 이름을 한 번에 바꿀 수 있는데 살펴보자.

<img width="475" alt="Image" src="https://github.com/user-attachments/assets/f7219af8-ef09-4b38-9ee8-f0f080e0feda" />

마우스 오른쪽 버튼을 눌러 Rename을 누르면 함수의 이름과 그것을 사용하는 곳까지 한 번에 변경이 가능하다.

**Mac IntelliJ 단축키 : shift + F6**

**after**

책에 나와있는대로 좋은 이름을 찾기 위해 **함수에 주석을 작성한 다음, 주석을 함수 이름으로 만들어본다.**

<img width="708" alt="Image" src="https://github.com/user-attachments/assets/852c635f-f723-4a53-9840-9ab14b1ba794" />

또한, 함수 매개변수로 `GHIssue`를 의존 할 필요가 없도록 함수 내부에서 repository를 읽도록 변경하였다.

### 2. 변수 이름 바꾸기 (Rename Variable)

- 더 많이 사용되는 변수일수록 그 이름이 더 중요하다.
    - 람다식에서 사용하는 변수 vs 함수의 매개변수
- 다이나믹 타입을 지원하는 언어에서는 타입을 이름에 넣기도 한다.
- 여러 함수에 걸쳐 쓰이는 필드 이름에는 더 많이 고민하고 이름을 짓는다.

**before**

<img width="706" alt="Image" src="https://github.com/user-attachments/assets/4c03be5d-6509-427c-887c-16637aa66552" />

함수 이름이 loadReviews로 reviews를 읽어오는데 함수 안에는 commets 를 읽어 오는게 부자연스럽다.

**after**

<img width="706" alt="Image" src="https://github.com/user-attachments/assets/d081512d-b7cb-498c-b548-5f5cc6af2fb0" />

comments라는 변수를 reviews로 변경하여 함수 이름에 맞게 변수 이름을 바꿔주었다.

### 3. 필드 이름 바꾸기 (Rename Field)

- Record 자료 구조의 필드 이름은 프로그램 전반에 걸쳐 참조될 수 있기 때문에 매우 중요하다.
    - Record 자료 구조: 특정 데이터와 관련있는 필드를 묶어놓은 자료 구조
    - 파이썬의 Dictionary
    - C#의 Record
    - 자바 14 버전부터 지원.
    - 자바에서는 Getter와 Setter 메소드 이름도 필드의 이름과 비슷하게 간주할 수 있음.

## 냄새 2. 중복코드 (Duplicated Code)

- 중복 코드의 단점
    - 비슷한지, 완전히 동일한 코드인지 주의 깊게 봐야한다.
    - 코드를 변경할 때, 동일한 모든 곳의 코드를 변경해야 한다.
- 사용할 수 있는 리팩토링 기술
    1. 동일한 코드를 여러 메소드레서 사용하는 경우, [함수 추출하기 (Extract Funtion)](#1-함수-추출하기-extract-funtion)
    2. 코드가 비슷하게 생겼지만 완전히 같지는 않은 경우, [코드 분리하기 (Slide Statements)](#2-코드-정리하기-slide-statements)
    3. 여러 하위 클래스에 동일한 코드가 있다면, [메소드 올리기 (Pull Up Method)](#3-메소드-올리기-pull-up-method)

### 1. 함수 추출하기 (Extract Funtion)

- “의도”와 “구현” 분리하기
- 무슨 일을 하는 코드인지 알아내려고 노력해야 하는 코드라면 해당 코드를 함수로 분리하고 함수 이름으로 “무슨 일을 하는지” 표현할 수 있다.
- 한줄 짜리 메소드도 괜찮은가?
- 거대한 함수 안에 들어있는 주석은 추출한 함수를 찾는데 있어서 좋은 단서가 될 수 있다.

**before**

<img width="705" alt="Image" src="https://github.com/user-attachments/assets/2e1d784b-6dab-4724-8125-aa67f33cbe0e" />

`printParticipants`와 `printReviewers`의 메서드를 보면 여러가지 구현과 중복된 코드들이 들어가있다.

**Mac IntelliJ 단축키 : opt + cmd + m**

**after**

<img width="704" alt="Image" src="https://github.com/user-attachments/assets/aa9406fc-6fe7-4a53-9f07-a53d0362b545" />

이처럼 중복된 코드들의 함수를 추출해 중복된 내용을 줄일 수 있다.

### 2. 코드 정리하기 (Slide Statements)

- 관련있는 코드끼리 묶여있어야 코드를 더 쉽게 이해할 수 있다.
- 함수에서 사용할 변수를 상단에 미리 정의하기 보다는, 해당 변수를 사용하는 코드 바로 위에 선언하자.
- 관련있는 코드끼리 묶은 다음, 함수 추출하기(Extract Function)를 사용해서 더 깔끔하게 분리 할 수도 있다.

### 3.  메소드 올리기 (Pull Up Method)

- 중복 코드는 당장은 잘 동작하더라도 미래에 버그를 만들어 낼 빌미를 제공한다.
    - 예) A에서 코드를 고치고, B에는 반영하지 않은 경우
- 여러 하위 클래스에 동일한 코드가 있다면, 손쉽게 이 방법을 적용할 수 있다.
- 비슷하지만 일부 값만 다른 경우라면, “함수 매개변수화하기” 리팩토링을 적용한 이후에, 이 방법을 사용할 수 있다.
- 하위 클래스에 있는 코드가 상위 클래스가 아닌 하위 클래스 기능에 의존하고 있다면 “필드 올리기”를 적용한 이후에 이 방법을 적용할 수 있다.
- 두 메소드가 비슷한 절차를 따르고 있다면, “템플릿 메소드 패턴” 적용을 고려할 수 있다.

## 냄새 3. 긴 함수 (Long Function)

- 짧은 함수 vs 긴 함수
    - 함수가 길수록 더 이해하기 어렵다 vs 짧은 함수는 더 많은 문맥 전환을 필요로 한다.
    - “과거에는” 작은 함수를 사용하는 경우에 더 많은 서브루틴 호출로 인한 오버헤드가 있었다.
    - 어떤 코드에 “주석”을 남기고 싶다면, 주석 대신 함수를 만들고 함수의 이름으로 “의도”를 표현해보자
- 사용할 수 있는 리팩토링 기술
    1. 99%, “함수 추출하기 (Extract Function)”로 해결 할 수 있다.
    2. 함수로 분리하면서 해당 함수로 전달해야 할 매개변수가 많아진다면 다음과 같은 리팩토링을 고려해볼 수 있다.
        
        [2-1. 임시 변수를 질의 함수로 바꾸기 (Replace Temp with Query)](#1-임시-변수를-질의-함수로-바꾸기-replace-temp-with-query)
        
        [2-2. 매개변수 객체 만들기 (Introduce Parameter Object)](#2-매개변수-객체-만들기-introduce-parameter-object)
        
        [2-3. 객체 통째로 넘기기 (Preserve Whole Object)](#3-객체-통째로-넘기기-preserve-whole-object)
        
    3. “[조건문 분해하기 (Decompose Conditional)](#5-조건문-분해하기-decompose-conditional)”를 사용해 조건문을 분리할 수 있다.
    4. 같은 조건으로 여러개의 Switch 문이 있다면, “[조건문을 다형성으로 바꾸기 (Replace Conditional with Polymorphism)](#7-조건문을-다형성으로-바꾸기-replace-conditional-with-polymorphism)”을 사용할 수 있다.
    5. 반복문 안에서 여러 작업을 하고 있어서 하나의 메소드로 추출하기 어렵다면, “[반복문 쪼개기 (Split Loop)](#6-반복문-쪼개기-split-loop)”를 적용할 수 있다.

### 1. 임시 변수를 질의 함수로 바꾸기 (Replace Temp with Query)

- 변수를 사용하면 반복해서 동일한 식을 계산하는 것을 피할 수 있고, 이름을 사용해 의미를 표현할 수도 있다.
- 긴 함수를 리팩토링할 때, 그러한 임시 변수를 함수로 추출하여 분리한다면 빼낸 함수로 전달해야 할 매개변수를 줄일 수 있다.

### 2. 매개변수 객체 만들기 (Introduce Parameter Object)

- 같은 매개변수들이 여러 메소드에 걸쳐 나타난다면 그 매개변수들을 묶은 자료 구조를 만들 수 있다.
- 그렇게 만든 자료구조는
    - 해당 데이터간의 관계를 보다 명시적으로 나타낼 수 있다.
    - 함수에 전달할 매개변수 개수를 줄일 수 있다.
    - 도메인을 이해하는데 중요한 역할을 하는 클래스로 발전할 수도 있다.

### 3. 객체 통째로 넘기기 (Preserve Whole Object)

- 어떤 한 레코드에서 구할 수 있는 여러 값들을 함수에 전달하는 경우, 해당 매개변수를 레코드 하나로 교체할 수 있다.
- 매개변수 목록을 줄일 수 있다. (향후에 추가할지도 모를 매개변수까지도…)
- 이 기술을 적용하기 전에 의존성을 고려해야한다.
- 어쩌면 해당 메소드의 위치가 적절하지 않을 수도 있다. (기능 편애 “Feature Envy” 냄새에 해당한다.)

### 4. 함수를 명령으로 바꾸기 (Replace Function with Command)

- 함수를 독립적인 객체인, Command로 만들어 사용할 수 있다.
- 커맨드 패턴을 적용하면 다음과 같은 장점을 취할 수 있다.
    - 부가적인 기능으로 undo 기능을 만들 수도 있다.
    - 더 복잡한 기능을 구현하는데 필요한 여러 메소드를 추가할 수 있다.
    - 상속이나 템플릿을 활용할 수도 있다.
    - 복잡한 메소드를 여러 메소드나 필드를 활용해 쪼갤 수도 있다.
- 대부분의 경우에 “커맨드” 보다는 “함수”를 사용하지만, 커맨드 말고 다른 방법이 없는 경우에만 사용한다.

### 5. 조건문 분해하기 (Decompose Conditional)

- 여러 조건에 따라 달라 달라지는 코드를 작성하다보면 종종 긴 함수가 만들어지는 것을 목격할 수 있다.
- “조건”과 “액션” 모두 “의도”를 표현해야한다.
- 기술적으로는 “함수 추출하기”와 동일한 리팩토링이지만 의도만 다를 뿐이다.

### 6. 반복문 쪼개기 (Split Loop)

- 하나의 반복문에서 여러 다른 작업을 하는 코드를 쉽게 찾아볼 수 있다.
- 해당 반복문을 수정할 때 여러 작업을 모두 고려하며 코딩을 해야한다.
- 반복문을 여러개로 쪼개면 보다 쉽게 이해하고 수정할 수 있다.
- 성능 문제를 야기할 수 있지만, “리팩토링”은 “성능 최적화”와 별개의 작업이다. 리팩토링을 마친 이후에 성능 최적화 시도할 수 있다.

### 7. 조건문을 다형성으로 바꾸기 (Replace Conditional with Polymorphism)

- 여러 타입에 따라 각기 다른 로직으로 처리해야 하는 경우에 다형성을 적용해서 조건문을 보다 명확하게 분리할 수 있다. (예, 책, 음악, 음식 등) 반복되는 switch 문을 각기 다른 클래스를 만들어 제거할 수 있다.
- 공통으로 사용되는 로직은 상위클래스에 두고 달라지는 부분만 하위클래스에 둠으로써, 달라지는 부분만 강조할 수 있다.
- 모든 조건문을 다형성으로 바꿔야 하는 것은 아니다.

## 냄새 4. 긴 매개변수 목록 (Long Parameter List)

- 어떤 함수에 매개변수가 많을수록 함수의 역할을 이해하기 어려워진다.
    - 과연 그 함수는 한가지 일을 하고 있는게 맞는가?
    - 불필요한 매개변수는 없는가?
    - 하나의 레코드로 뭉칠 수 있는 매개변수 목록은 없는가?
- 어떤 매개변수를 다른 매개변수를 통해 알아낼 수 있다면, “[매개변수를 질의 함수로 바꾸기 (Replace Parameter with Query)](#1-매개변수를-질의-함수로-바꾸기-replace-parameter-with-query)”를 사용할 수 있다.
- 기존 자료구조에서 세부적인 데이터를 가져와서 여러 매개변수로 넘기는 대신 “객체 통째로 넘기기 (Preserve Whole Object)”를 사용할 수 있다.
- 일부 매개변수들이 대부분 같이 넘겨진다면, “매개변수 객체 만들기 (Introduce Parameter Object)”를 적용할 수 있다.
- 매개변수가 플래그로 사용된다면, “[플래그 인수 제거하기 (Remove Flag Argument)](#2-플래그-인수-제거하기-remove-flag-argument)”를 사용할 수 있다.
- 여러 함수가 일부 매개변수를 공통적으로 사용한다면 “[여러 함수를 클래스로 묶기 (Combine Functions into Class)](#3-여러-함수를-클래스로-묶기-combine-functions-into-class)” 통해 매개변수를 해당 클래스의 필드로 만들고 메서드에 전달해야 할 매개변수 목록을 줄일 수 있다.

### 1. 매개변수를 질의 함수로 바꾸기 (Replace Parameter with Query)

- 함수의 매개변수 목록은 함수의 다양성을 대변하며, 짧을수록 이해하기 좋다.
- 어떤 한 매개변수를 다른 매개변수를 통해 알아낼 수 있다면 “중복 매개변수”라 생각할 수 있다.
- 매개변수에 값을 전달하는 것은 “함수를 호출하는 쪽”의 책임이다. 가능하면 함수를 호출하는 쪽의 책임을 줄이고 함수 내부에서 책임지도록 노력한다.
- “임시 변수를 질의 함수로 바꾸기”와 “함수 선언 변경하기”를 통해 이 리팩토링을 적용한다.

### 2. 플래그 인수 제거하기 (Remove Flag Argument)

- 플래그는 보통 함수에 매개변수로 전달해서, 함수 내부의 로직을 분기하는데 사용한다.
- 플래그를 사용한 함수는 차이를 파악하기 어렵다.
    - bookConcert(customer, false), bookConcert(customer, true)
    - bookConcert(customer), premiumBookConcert(customer)
- 조건문 분해하기 (Decompose Condition)를 활용할 수 있다.

### 3. 여러 함수를 클래스로 묶기 (Combine Functions into Class)

- 비슷한 매개변수 목록을 여러 함수에서 사용하고 있다면 해당 메소드를 모아서 클래스를 만들 수 있다.
- 클래스 내부로 메소드를 옮기고, 데이터를 필드로 만들면 메소드에 전달해야 하는 매개변수 목록도 줄일 수 있다.

## 냄새 5. 전역 데이터 (Global Data)

- 전역 데이터 (ex, 자바의 public static 변수)
- 전역데이터는 아무곳에서나 변경될 수 있다는 문제가 있다.
- 어떤 코드로 인해 값이 바뀐 것인지 파악하기 어렵다.
- 클래스 변수(필드)도 비슷한 문제를 겪을 수 있다.
- “[변수 캡슐화하기 (Encapsulate Variable)](#1-변수-캡슐화하기-encapsulate-variable)”를 적용해서 접근을 제어하거나 어디서 사용하는지 파악하기 쉽게 만들 수 있다.
- 파라켈수스의 격언, “약과 독의 차이를 결정하는 것은 사용량일 뿐이다.”

### 1. 변수 캡슐화하기 (Encapsulate Variable)

- 메소드는 점진적으로 새로운 메소드로 변경할 수 있으나, 데이터는 한번에 모두 변경해야 한다.
- 데이터 구조를 변경하는 작업을 그보다는 조금 더 수월한 메소드 구조 변경 작업으로 대체할 수 있다.
- 데이터가 사용되는 범위가 클수록 캡슐화를 하는 것이 더 중요해진다.
    - 함수를 사용해서 값을 변경하면 보다 쉽게 검증 로직을 추가하거나 변경에 따르는 후속 작업을 추가하는 것이 편리하다.
- 불변 데이터의 경우에는 이런 리팩토링을 적용할 필요가 없다.

