# 2장 주변 친구

1장 ‘근접성 서비스’와 비슷해 보이는 검색 기능이지만 두 기능 사이에 큰 차이가 있다.

근접성 서비스의 경우 사업장 주소는 정적이지만, 주변 친구 위치는 자주 바뀔수 있기 때문이다.

## 1단계: 문제 이해 및 설계 범위 확정

### 기능 요구사항

- 사용자는 모바일 앱에서 주변 친구를 확인할 수 있어야 한다. 주변 친구 목록에 보이는 각 항목에는 해당 친구까지의 거리, 그리고 해당정보가 마지막으로 갱신된 시각이 함께 표시되어야 한다.
- 친 구 목록은 몇 초마다 한 번씩 갱신됭여 한다.

### 비기능 요구사항

- 낮은 지연 시간 : 주변 친구의 위치 변화가 반영되는 데 너무 오랜 시간이 걸리지 않아야 한다.
- 안정성 : 전반적인 안정성, 때로 몇개 데이터가 유실되는 것 정도는 용인할 수 있다.
- 결과적 일관성 : 복제본의 데이터가 원본과 동일하게 변경되기까지 몇 초 정도 걸리는 것은 용인할 수 있다.

### 개략적 규모 추정

- ‘주변 친구’는 5마일(8km) 반경 이내 친구로 정의한다.
- 친구 위치 정보는 30초 주기로 갱신한다. 사람이 걷는 속도가 시간당 3~4마일(4~6km/h)정도로 느리기 때문
- 평균적으로 매일 주변 친구 검색 기능을 활용하는 사용자는 1억 명으로 가정한다.
- 동시 접속 사용자의 수는 일간 능동 사용자 수의 10%로 가정한다. 따라서 천만명이 동시에 시스템을 이용한다고 가정한다.
- 평균적으로 한 사용자는 400명의 친구를 갖는다고 가정한다.
- 이 기능을 제공하는 앱은 페이지당 20명의 주변 친구를 표시하고, 사용자 요청이 있으면 더 많은 주변 친구를 보여준다.

## 2단계: 개략적 설계안 제시 및 동의 구하기

1. 개략적 설계
2. API 설계
3. 데이터 모델

우치 정보를 모든 친구에게 전송(push)해야 하는데 클라이언트와 서버 사이의 통신 프로토콜로 단순한 HTTP 프로토콜을 사용하지 못하게 될 수 있음을 감안하여 개략적 설계안을 먼저 이해하도록 먼저 살펴보자.

### 1. 개략적 설계안

**P2P(peer-to-peer) 방식**

활성 상태인 근방 모든 친구와 항구적 통신 상태를 유지하는 것이다.

![image](https://github.com/Jammini/TIL/assets/59176149/b19778db-4d16-49cc-ad1c-b8a360effd28)

모바일 단말은 통신 연결 상태가 좋지 않은 경우도 있고 사용할 수 있는 전력도 충분치 않아 실료적인 아이디어는 아니다.

**공용 백엔드 방식**

![image](https://github.com/Jammini/TIL/assets/59176149/c68f912d-7e22-4bce-841b-f70866e6ec5e)

- 모든 활성 상태 사용자의 위치 변화 내역을 수신
- 사용자 위치 변경 내역을 수신할 때마다 해당 사용자의 모든 활성 상태 친구를 찾아서 그 친구들의 단말로 변경 내역 전달
- 두 사용자 사이의 거리가 특정 임계치보다 먼 경우에는 변경 내역을 전송하지 않는다.

### 설계안

![image](https://github.com/Jammini/TIL/assets/59176149/af57add5-f968-410e-ac7a-b878fb97f760)

**로드밸런서**

RESTful API 서버 및 양방향 유상태(stateful) 웹소켓 서버 앞단에 위치 한다. 부하를 고르게 분산하기 위해 트래픽을 서버들에 배분하는 역할을 한다.

**웹소켓 서버**

친구 위치 정보 변경을 거의 실시간에 가깝게 처리하는 유상태 서버 클러스터다.

검색 반경 내 친구 위치가 변경되면 해당 내역은 이 연결을 통해 클라이언트로 전송된다.

**레디스 위치 정보 캐시**

레디스는 활성 상태 사용자의 가장 최근 위치 정보를 캐시하는 데 사용한다.

**사용자 데이터베이스**

사용자 데이터 및 사용자의 친구 관계 정보를 저장한다.

**위치 이동 이력 데이터베이스**

위치 변동 이력을 보관한다. 주변 친구 표시와 직접 관계된 기능은 아니다.

**레디스 펍/섭 서버**

레디스 펍/섭(Pub/Sub)은 초경량 메시지 버스다. 레디스 펍/섭에 새로운 채널을 생성하는 것은 아주 값싼 연산이다. 본 설계안의 경우 웹소켓 서버를 통해 수신한 특정 사용자의 위치 정보 변경 이벤트는 해당 사용자에게 배정된 펍/섭 채널에 발행한다. 해당 사용자의 친구 각각과 연결된 웹소켓 연결 핸드러는 해당 채널의 구독자로 설정되어 있다.

**주기적 위치 갱신**

모바일 클라이언트는 항구적으로 유지되는 웹소켓 연결을 통해 주기적으로 위치 변경 내역을 전송한다.

![image](https://github.com/Jammini/TIL/assets/59176149/0719cdb8-0b3f-48d0-9bce-e663ae4651b5)

1. 모바일 클라이엍트가 위치가 변경된 사실을 로드밸런서에 전송한다.
2. 로드밸런서는 그 위치 변경 내역을 해당 클라이언트와 웹소켓 서버 사이에 설정된 연결을 통해 웹소켓 서버로 보낸다.
3. 웹소켓 서버는 해당 이벤트를 위치 이동 이력 데이터베이스에 저장한다.
4. 웹소켓 서버는 새 위치를 위치 정보 캐시에 보관한다. 이때 TTL도 새롭게 갱신한다. 또한 웹소켓 서버는 웹소켓 연결 핸들러 안의 변수에 해당 위치를 반영한다. 이 변수에 갱신한 값은 뒤이은 거리 계산과정에 이용된다.
5. 웹소켓 서버는 레디스 펍/섭 서버의 해당 사용자 채널에 새 위치를 발행한다. 3부터 5까지의 각 단계는 병렬로 수행한다.
6. 레디스 펍/섭 채널에 발행된 새로운 위치 변경 이벤트는 모든 구독자(즉, 웹소켓 이벤트 핸들러)에게 브로드캐스트 된다. 이때 구독자는 위치 변경 이벤트를 보낸 사용자의 온라인 상태 친구들이다. 그 결과 각 구독자의 웹소켓 연결 핸드러는 친구의 위치 변경 이벤트를 수신하게 된다.
7. 메시지를 받은 웹소켓 서버, 즉 상기 웹소켓 연결 핸들러가 위치한 웹소켓 서버는 새 위치를 보낸 사용자와 메시지를 받은 사용자(그 위치는 웹소켓 연결 핸들러 내의 변수에 보관되어 있다) 사이의 거리를 새로 계산한다.
8. 거리가 검색 반경을 넘지 않는다면, 구독자의 클라이언트 앱으로 전송하고 검색 반경을 넘는다면 보내지 않는다.

![image](https://github.com/Jammini/TIL/assets/59176149/c645fdfe-8381-4376-a713-550913ed5d4d)

### 2. API 설계

웹소켓: 사용자는 웹소켓 프로토콜을 통해 위치 정보 변경 내역을 전송하고 수신한다.

1. [서버 API] 주기적인 위치 정보 갱신
    
    요청: 클라이언트는 위도, 경도, 시각 정보를 전송
    
    응답: 없음
    
2. [클라이언트 API] 클라이언트가 갱신된 친구 위치를 수신하는 데 사용할 API
    
    전송되는 데이터: 친구 위치 데이터와 변경된 시각을 나타내는 타임스탬프
    
3. [서버 API] 웹소켓 초기화 API
    
    요청: 클라이언트 위도, 경도, 시각 정보를 전송
    
    응답: 클라이언트는 자기 친구들의 위치 데이터를 수신
    
4. [클라이언트 API] 새 친구 구독 API
    
    요청: 웹소켓 서버는 친구 ID 전송
    
    응답: 가장 최근의 위도, 경도, 시각 정보 전송
    
5. [클라이언트 API] 구독 해지 API
    
    요청: 웹 소켓 서버는 친구 ID 전송
    
    응답: 없음
    

### 3. 데이터 모델

**위치 정보 캐시**

위치 정보 캐시는 ‘주변친구’ 기능을 켠 활성 상태 친구의 가장 최근 위치를 보관한다. 해당 캐시에 보관될 키/값 상은 KEY: 사용자 ID, VALUE: {위도, 경도, 시각} 이다.

**위치 정보 저장에 데이터베이스를 사용하지 않는 이유는?**

‘주변 친구’기능은 사용자의 현재 위치만을 이용한다. 따라서 사용자 위치는 하나만 보관하면 충분하다.

**위치 이동 이력 데이터베이스**

우리가 필요로 하는 것은 막대한 쓰기 연산 부하를 감당할 . 수있고 수평적 규모 확장이 가능한 데이터베이스다. 관계형 데이터베이스도 사용할 수 있으나 이력 데이터의 양이 서버 한 대에 보관하기에는 너무 많을 수 있으므로 샤딩이 필요하다. 사용자 ID를 기준 삼는 샤딩 방안이 가장 기본이다. 부하를 모든 샤드에 고르게 분산시킬 수 있고, 데이터베이스 운영 관리도 간편한 방법이다.

## 3단계: 상세 설계

### 중요 구성 요소별 규모 확장성

**API 서버**

RESTful API 서버의 규모 확장 방법은 널리 알려져 있다.

scale out, scale up

**웹소켓 서버**

웹소켓 클러스터도 사용률에 따라 규모를 자동으로 늘리는것은 어렵지 않다.

유상태 서버 클러스터의 규모를 자동으로 확장하려면 좋은 로드밸런서가 있어야 한다. 대부분의 클라우드 로드밸런서는 이일을 잘 처리한다.

**클라이언트 초기화**

웹소켓 연결이 초기화되면 클라이언트는 해당 모바일 단말의 위치, 즉 해당 단말을 이용 중인 사용자의 위치 정보를 전송한다.

1. 위치 정보 캐시에 보관된 해당 사용자의 위치를 갱신한다.
2. 해당 위치 정보는 뒤이은 계산 과정에 이용되므로, 연결 핸들러 내의 변수에 저장해 둔다.
3. 사용자 데이터베이스를 뒤져 해당 사용자의 모든 친구 정보를 가져온다.
4. 위치 정보 캐시에 일관(batch) 요청을 보내어 모든 친구의 위치를 한번에 가져온다. 캐시에 보관하는 모든 항목의 TTL은 비활성화 타임아웃 시간과 동일한 값으로 설정되어 있으므로, 비활성화 친구의 위치는 캐시에 없을 것이다.
5. 캐시가 돌려준 친구 위치 각각에 대해, 웹소켓 서버는 해당 친구와 사용자 사이의 거리를 계산한다. 검색 반경 이내면 계산된 값을 클라이언트에 반환한다.
6. 웹소켓 서버는 각 친구의 레디스 펍/섭 채널을 구독한다.
7. 사용자의 현재 위치를 레디스 펍/섭 서버의 전용 채널을 통해 모든 친구에게 전송한다.

**사용자 데이터베이스**

사용자 데이터베이스에는 두가지 종류의 데이터가 보관된다.

첫번째는 사용자 ID, 사용자명, 프로파일 이미지의 URL 등을 아우르는 사용자 상세 정보 데이터이다

두번째는 친구관계 데이터이다,

각각의 데이터는 내부 API를 통해 이용해야만 하는 점이다.

**위치 정보 캐시**

활성화 상태 사용자의 위치 정보를 캐시하기 위해 레디스를 활용

각 항목의 키에는 TTL을 설정하는데 TTL은 해당 사용자의 위치 정보가 갱신될때마다 초기화된다.

**레디스 펍/섭 서버**

펍/섭 서버를 모든 온라인 친구에게 보내는 위치 변경 내역 메시지의 라우팅 계층으로 활용된다. 레디스 펍/섭을 선택한 이유는 채널을 만드는 비용이 아주 저렴하기 때문이다. 새 채널은 구독하려는 채널이 없을때 생성한다.

**얼마나 많은 레디스 펍/섭 서버가 필요한가?**

- 레디스 펍/섭 서버의 병목은 메모리가 아니라 CPU사용량이다
- 본 설계안이 풀어야 하는 문제의 규모를 감당하려면 분산 레디스 펍/섭 클러스터가 필요하다.

**분산 레디스 펍/섭 서버 클러스터**

모든 채널은 서로 독립적이기에 메시지를 발행할 사용자 ID를 기준으로 펍/섭 서버들을 샤딩하면 된다.

**레디스 펍/섭 서버 클러스터의 규모확장 고려사항**

무상태 서버로 구성된 클러스터는 위험성이 낮고 비용을 절감하기 좋다.

유상태 서버 클러스터인 경우 운영 부담과 위험이 큰 작업이므로 주의 깊게 계획하고 진행해야 한다.

**운영 고려사항**

기존 레디스 펍/섭 서버를 새 서버로 교체할 때 운영 문제가 발생할 가능성은 클러스터 크기를 조정할 때보다 낮다. 교체되는 서버의 채널만 손보면 되기때문이다.

**친구추가/삭제**

새 친구를 추가하면 클라이언트에 연결된 웹소켓 서버의 연결 핸들러에 사실을 알려야 한다. 그래야 새 친구의 펍/섭 채널을 구독할 수 있기 때문이다.

**친구가 많은 사용자**

수천 명의 친구를 구독하는 데 필요한 펍/섭 구독 관계는 클러스터 내의 많은 웹소켓 서버에 분산되어 있을 것이다. 따라서 친구들의 위치가 변경되는 데서 오는 부하는 각 웹소켓 서버가 나누어 처리하므로 핫스팟 문제는 발생하지 않을 것이다.

**주변의 임의 사용자**

위치 정보 공유에 동의한 주변 사용자를 무작귀로 보여줄 수 있도록 해보자고 한다면?

기존 설계안을 크게 훼손하지 않고 지오해시에 따라 구축된 펍/섭 채널 풀을 두는 것이다.

![image](https://github.com/Jammini/TIL/assets/59176149/3a73ab9b-99ae-4930-80d8-b2ec0312e329)

**레디스 펍/섭 외의 대안**

라우팅 계층으로 레디스 펍/섭을 사용하였으나 얼랭(Erlang) 전문가가 있다면 좋은 선택지가 될 . 수있다.

얼랭의 강력함은 경량프로세스에 나온다. 비용도 아주 저렴하고 여러 서버로 분산하기도 쉽다. 운영 부담도 지극히 낮으며 프로덕션에서 발생하는 이슈의 실시간 디버깅을 지원하는 훌륭한 도구들을 갖추며 배포도구도 강력하다.

## 4단계: 마무리

이 설계안의 핵심 컴포넌트는 다음과 같다

- 웹소켓: 클라이언트와 서버 사이의 실시간 통신을 지원한다.
- 레디스: 위치 데이터의 빠른 읽기/쓰기를 지원한다.
- 레디스 펍/섭: 한 사용자의 위치 정보 변경 내역을 모든 온라인 친구에게 전달하는 라우팅 계층이다.

![image](https://github.com/Jammini/TIL/assets/59176149/6a5614f7-bd98-437b-bca2-6a895cee9148)
