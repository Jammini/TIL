# Kafka vs RabbitMQ vs Redis

### 목차

1. [개요](#1-개요)
2. [Kafka](#2-kafka)
3. [RabbitMQ](#3-rabbitmq)
4. [Redis Pub/Sub](#4-redis-pubsub)
5. [결론](#5-결론)

### 1. 개요

Kafka, RabbitMQ, Redis의 Pub/Sub 을 비교하면 각각의 시스템이 메시징 패턴을 구현하는 방식과 그에 따른 성능, 확장성 유연성 측면에서 상이한 특징을 나타낸다.

이 세가지 시스템을 각가의 관점에서 비교해보려고 한다.

### 2. Kafka

<img width="578" alt="image" src="https://github.com/Jammini/TIL/assets/59176149/b44ccb8f-416f-42b6-a2dc-2ee143a64812">

**개념**

- 토픽 기반의 Pub/Sub 모델을 사용한다. Producer(게시자)는 특정 토픽에 메시지를 게시하고, Consumer(구독자)는 관심 있는 토픽을 구독하여 메시지를 소비한다.

**성능 및 확장성**

- 높은 처리량과 데이터 내구성, 분산 처리에 강점을 가지며, 대량의 데이터 스트림 처리에 최적화되어 있다. 대규모 시스템에서 확장성이 매우 뛰어난다.

**유연성**

- 뛰어난 확장성과 함께 메시지 순서 보장, 백로그 관리 등 다양한 기능을 제공한다.
- 하지만 Pub/Sub 이상의 복잡한 메시징 패턴을 구현하기 위해서는 추가적인 설계가 필요하다.

### 3. RabbitMQ

<img width="577" alt="image" src="https://github.com/Jammini/TIL/assets/59176149/534f48a8-7856-47ad-b454-a35bff9a4aa7">

**개념**

- RabbitMQ에서는 AMQP 프로토콜을 사용하여 더 다양하고 유연한 메시징 패턴을 지원한다.

```
AMQP(Advanced Message Queuing Protocol) :
메세지 지향 미들웨어를 위한 개방형 표준 응용 계층 프로토콜
```

- Pub/Sub는 교환기(exchage)와 큐를 통해 구현되며, 메시지는 교환기를 통해 바인딩된 큐로 라우팅된다.

**성능 및 확장성**

- RabbitMQ는 메시지 브로커 중에서도 뛰어난 성능을 제공하지만 Kafka와 비교할 때 처리량과 확장성에서는 뒤처질 수 있다.
- 그러나 대부분의 엔터프라이즈 애플리케이션에 충분한 성능을 제공한다.

**유연성**

- 다양한 메시징 패턴을 손쉽게 구현할 수 있으며, 메시지를 유연하게 라우팅하고 관리할 수 있는 많은 기능을 제공한다.

### 4. Redis Pub/Sub

<img width="574" alt="image" src="https://github.com/Jammini/TIL/assets/59176149/9ebb7f70-9277-4d40-8726-3c1019ff301e">

**개념**

- Pub/Sub 기능은 간단한 토픽 기반 메시징 시스템을 제공한다. 게시자가 특정 채널에 메시지를 게시하면, 해당 채널을 구독하는 구독자가 메시지를 받는다.

**성능 및 확장성**

- 메모리 기반의 데이터 스토어이므로 매우 빠른 성능을 제공한다.
- 메시지가 지속되지 않으므로 Kafka나 RabbitMQ와 같은 메시지 브로커에 비해 내구성이 떨어진다.
- 확장성은 Redis 클러스터를 통해 해결할 수 있으나, Kafka처럼 대규모 데이터 처리에는 최적화되어 있지 않는다.

**유연성**

- Pub/Sub는 기본적인 사용 사례에 적합하다.
- 메시지 큐잉이나 복잡한 메시징 요구 사항을 충족시키기 위한 추가 기능은 제한적이다.

### 5. 결론

- **Kafka**는 대규모 데이터 스트림 처리와 높은 처리량이 필요한 시스템에 적합하다.
- **RabbitMQ**는 메시지 라우팅과 다양한 메시징 패턴을 필요로 하는 복잡한 애플리케이션에 유용하다.
- **Redis Pub/Sub**은 빠른 성능이 필요하고 메시지 지속성이 중요하지 않은 간단한 Pub/Sub 시나리오에 적합하다.

각 기술의 선택은 애플리케이션의 특정 요구 사항, 메시지 처리량, 지속성 요구 사항, 그리고 개발 및 유지 관리 용이성에 따라 달라질 수 있을 것이다.